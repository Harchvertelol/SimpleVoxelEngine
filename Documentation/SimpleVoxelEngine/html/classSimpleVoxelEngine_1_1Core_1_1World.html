<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>SimpleVoxelEngine: Класс World</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SimpleVoxelEngine
   &#160;<span id="projectnumber">build 0.0.1</span>
   </div>
   <div id="projectbrief">Воксельный движок</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Создано системой Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Поиск');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Титульная&#160;страница</span></a></li>
      <li><a href="pages.html"><span>Описания</span></a></li>
      <li><a href="namespaces.html"><span>Пространства&#160;имен</span></a></li>
      <li class="current"><a href="annotated.html"><span>Классы</span></a></li>
      <li><a href="files.html"><span>Файлы</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Поиск" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Классы</span></a></li>
      <li><a href="classes.html"><span>Алфавитный&#160;указатель&#160;классов</span></a></li>
      <li><a href="hierarchy.html"><span>Иерархия&#160;классов</span></a></li>
      <li><a href="functions.html"><span>Члены&#160;классов</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>Указатель</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Классы</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Пространства имен</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Файлы</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Функции</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Переменные</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Перечисления</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Элементы перечислений</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Страницы</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSimpleVoxelEngine.html">SimpleVoxelEngine</a></li><li class="navelem"><a class="el" href="namespaceSimpleVoxelEngine_1_1Core.html">Core</a></li><li class="navelem"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1World.html">World</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Открытые члены</a> &#124;
<a href="classSimpleVoxelEngine_1_1Core_1_1World-members.html">Полный список членов класса</a>  </div>
  <div class="headertitle">
<div class="title">Класс World</div>  </div>
</div><!--header-->
<div class="contents">

<p>Воксельный мир.  
 <a href="classSimpleVoxelEngine_1_1Core_1_1World.html#details">Подробнее...</a></p>

<p><code>#include &quot;<a class="el" href="World_8h_source.html">World.h</a>&quot;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Открытые члены</h2></td></tr>
<tr class="memitem:a68980dfd830f0fda3be7203b896243ac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1World.html#a68980dfd830f0fda3be7203b896243ac">World</a> (<a class="el" href="classSimpleVoxelEngine_1_1Core_1_1Engine.html">Engine</a> *eng, std::string folder, bool message=true)</td></tr>
<tr class="memdesc:a68980dfd830f0fda3be7203b896243ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Стандартный конструктор  <a href="#a68980dfd830f0fda3be7203b896243ac">Подробнее...</a><br /></td></tr>
<tr class="separator:a68980dfd830f0fda3be7203b896243ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa94d10b972c80bec09174fafc1a888f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1World.html#afa94d10b972c80bec09174fafc1a888f">World</a> (<a class="el" href="classSimpleVoxelEngine_1_1Core_1_1Engine.html">Engine</a> *eng, std::string folder, int sizechunk)</td></tr>
<tr class="memdesc:afa94d10b972c80bec09174fafc1a888f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Конструктор  <a href="#afa94d10b972c80bec09174fafc1a888f">Подробнее...</a><br /></td></tr>
<tr class="separator:afa94d10b972c80bec09174fafc1a888f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd170ded455f0b2273c1fe06da6ea0cb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd170ded455f0b2273c1fe06da6ea0cb"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1World.html#abd170ded455f0b2273c1fe06da6ea0cb">~World</a> ()</td></tr>
<tr class="memdesc:abd170ded455f0b2273c1fe06da6ea0cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Стандартный деструктор. <br /></td></tr>
<tr class="separator:abd170ded455f0b2273c1fe06da6ea0cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f1203e5d10c03c78844f334971d7d77"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1World.html#a6f1203e5d10c03c78844f334971d7d77">loadChunk</a> (<a class="el" href="classSimpleVoxelEngine_1_1Additional_1_1Vector3d.html">SimpleVoxelEngine::Additional::Vector3d</a>&lt; int &gt; vect)</td></tr>
<tr class="memdesc:a6f1203e5d10c03c78844f334971d7d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Загрузка чанка.  <a href="#a6f1203e5d10c03c78844f334971d7d77">Подробнее...</a><br /></td></tr>
<tr class="separator:a6f1203e5d10c03c78844f334971d7d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af18015e9bcd1335eba4951f8b359f576"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1World.html#af18015e9bcd1335eba4951f8b359f576">loadChunks</a> (<a class="el" href="classSimpleVoxelEngine_1_1Additional_1_1Vector3d.html">SimpleVoxelEngine::Additional::Vector3d</a>&lt; int &gt; vect, int cube_radius)</td></tr>
<tr class="memdesc:af18015e9bcd1335eba4951f8b359f576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Загрузка блока чанков.  <a href="#af18015e9bcd1335eba4951f8b359f576">Подробнее...</a><br /></td></tr>
<tr class="separator:af18015e9bcd1335eba4951f8b359f576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55172f487483e850285d1bc6b6147fdd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1World.html#a55172f487483e850285d1bc6b6147fdd">progressiveLoadChunks</a> (<a class="el" href="classSimpleVoxelEngine_1_1Additional_1_1Vector3d.html">SimpleVoxelEngine::Additional::Vector3d</a>&lt; int &gt; vect_old, int cube_radius_old, <a class="el" href="classSimpleVoxelEngine_1_1Additional_1_1Vector3d.html">SimpleVoxelEngine::Additional::Vector3d</a>&lt; int &gt; vect_new, int cube_radius_new, bool save=true)</td></tr>
<tr class="memdesc:a55172f487483e850285d1bc6b6147fdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Интеллектуальная загрузка чанков.  <a href="#a55172f487483e850285d1bc6b6147fdd">Подробнее...</a><br /></td></tr>
<tr class="separator:a55172f487483e850285d1bc6b6147fdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95dd9f0d12e78ea10eceeebe8c2da82d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1World.html#a95dd9f0d12e78ea10eceeebe8c2da82d">unloadChunk</a> (<a class="el" href="classSimpleVoxelEngine_1_1Additional_1_1Vector3d.html">SimpleVoxelEngine::Additional::Vector3d</a>&lt; int &gt; vect, bool save=true, bool saveplace=false)</td></tr>
<tr class="memdesc:a95dd9f0d12e78ea10eceeebe8c2da82d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Выгрузка чанка из памяти.  <a href="#a95dd9f0d12e78ea10eceeebe8c2da82d">Подробнее...</a><br /></td></tr>
<tr class="separator:a95dd9f0d12e78ea10eceeebe8c2da82d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0326009a58fd830bd706b38ed2090e7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1World.html#ad0326009a58fd830bd706b38ed2090e7">unloadChunks</a> (<a class="el" href="classSimpleVoxelEngine_1_1Additional_1_1Vector3d.html">SimpleVoxelEngine::Additional::Vector3d</a>&lt; int &gt; vect, int cube_radius, bool save=true)</td></tr>
<tr class="memdesc:ad0326009a58fd830bd706b38ed2090e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Выгрузка чанков из памяти.  <a href="#ad0326009a58fd830bd706b38ed2090e7">Подробнее...</a><br /></td></tr>
<tr class="separator:ad0326009a58fd830bd706b38ed2090e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c2c75cb8bc4d45fcd8cec8b53f7f6f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1World.html#a5c2c75cb8bc4d45fcd8cec8b53f7f6f9">saveChunk</a> (<a class="el" href="classSimpleVoxelEngine_1_1Additional_1_1Vector3d.html">SimpleVoxelEngine::Additional::Vector3d</a>&lt; int &gt; vect)</td></tr>
<tr class="memdesc:a5c2c75cb8bc4d45fcd8cec8b53f7f6f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Сохранение чанка.  <a href="#a5c2c75cb8bc4d45fcd8cec8b53f7f6f9">Подробнее...</a><br /></td></tr>
<tr class="separator:a5c2c75cb8bc4d45fcd8cec8b53f7f6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30313fd6083b17a7d3d4418cd713a328"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1World.html#a30313fd6083b17a7d3d4418cd713a328">saveChunks</a> (<a class="el" href="classSimpleVoxelEngine_1_1Additional_1_1Vector3d.html">SimpleVoxelEngine::Additional::Vector3d</a>&lt; int &gt; vect, int cube_radius)</td></tr>
<tr class="memdesc:a30313fd6083b17a7d3d4418cd713a328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Сохранение чанков.  <a href="#a30313fd6083b17a7d3d4418cd713a328">Подробнее...</a><br /></td></tr>
<tr class="separator:a30313fd6083b17a7d3d4418cd713a328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6568f5c99a15e2c9c92cd17ff3da9d2e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1World.html#a6568f5c99a15e2c9c92cd17ff3da9d2e">writeWorldInfo</a> ()</td></tr>
<tr class="memdesc:a6568f5c99a15e2c9c92cd17ff3da9d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Запись информации о мире на диск.  <a href="#a6568f5c99a15e2c9c92cd17ff3da9d2e">Подробнее...</a><br /></td></tr>
<tr class="separator:a6568f5c99a15e2c9c92cd17ff3da9d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a7bf056122dcb7db06ee62603ccfa7"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1World.html#a57a7bf056122dcb7db06ee62603ccfa7">getNameFolder</a> ()</td></tr>
<tr class="memdesc:a57a7bf056122dcb7db06ee62603ccfa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить имя папки мира.  <a href="#a57a7bf056122dcb7db06ee62603ccfa7">Подробнее...</a><br /></td></tr>
<tr class="separator:a57a7bf056122dcb7db06ee62603ccfa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fdfc853c422711e734aaebd4a3efcd7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimpleVoxelEngine_1_1Voxels_1_1SimpleVoxelObject.html">SimpleVoxelEngine::Voxels::SimpleVoxelObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1World.html#a9fdfc853c422711e734aaebd4a3efcd7">getSimpleVoxelObject</a> (<a class="el" href="classSimpleVoxelEngine_1_1Core_1_1VoxelAddress.html">VoxelAddress</a> *addr, bool isexists=true)</td></tr>
<tr class="memdesc:a9fdfc853c422711e734aaebd4a3efcd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получить SimpleVoxelObject по <a class="el" href="classSimpleVoxelEngine_1_1Core_1_1VoxelAddress.html" title="Адрес вокселя. ">VoxelAddress</a>.  <a href="#a9fdfc853c422711e734aaebd4a3efcd7">Подробнее...</a><br /></td></tr>
<tr class="separator:a9fdfc853c422711e734aaebd4a3efcd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922cb803428be433e73c597a3893e7c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1World.html#a922cb803428be433e73c597a3893e7c0">setSimpleVoxelObject</a> (<a class="el" href="classSimpleVoxelEngine_1_1Core_1_1VoxelAddress.html">SimpleVoxelEngine::Core::VoxelAddress</a> *addr, <a class="el" href="classSimpleVoxelEngine_1_1Voxels_1_1SimpleVoxelObject.html">SimpleVoxelEngine::Voxels::SimpleVoxelObject</a> *svo, bool rewrite=false)</td></tr>
<tr class="memdesc:a922cb803428be433e73c597a3893e7c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Установка SimpleVoxelObject по <a class="el" href="classSimpleVoxelEngine_1_1Core_1_1VoxelAddress.html" title="Адрес вокселя. ">VoxelAddress</a>.  <a href="#a922cb803428be433e73c597a3893e7c0">Подробнее...</a><br /></td></tr>
<tr class="separator:a922cb803428be433e73c597a3893e7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860605dc2663d5a9c66b51f4fb23b67d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1World.html#a860605dc2663d5a9c66b51f4fb23b67d">deleteSimpleVoxelObject</a> (<a class="el" href="classSimpleVoxelEngine_1_1Core_1_1VoxelAddress.html">VoxelAddress</a> *addr)</td></tr>
<tr class="memdesc:a860605dc2663d5a9c66b51f4fb23b67d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Удаление SimpleVoxelObject по <a class="el" href="classSimpleVoxelEngine_1_1Core_1_1VoxelAddress.html" title="Адрес вокселя. ">VoxelAddress</a>.  <a href="#a860605dc2663d5a9c66b51f4fb23b67d">Подробнее...</a><br /></td></tr>
<tr class="separator:a860605dc2663d5a9c66b51f4fb23b67d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef367623a763d208060c6a727169067d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimpleVoxelEngine_1_1Voxels_1_1ChunkVoxelObject.html">SimpleVoxelEngine::Voxels::ChunkVoxelObject</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1World.html#aef367623a763d208060c6a727169067d">getChunk</a> (<a class="el" href="classSimpleVoxelEngine_1_1Additional_1_1Vector3d.html">SimpleVoxelEngine::Additional::Vector3d</a>&lt; int &gt; vect)</td></tr>
<tr class="memdesc:aef367623a763d208060c6a727169067d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получение чанка.  <a href="#aef367623a763d208060c6a727169067d">Подробнее...</a><br /></td></tr>
<tr class="separator:aef367623a763d208060c6a727169067d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0175d4bc32120485fc72bd914d8eaa99"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1World.html#a0175d4bc32120485fc72bd914d8eaa99">isExistsChunkInMemory</a> (<a class="el" href="classSimpleVoxelEngine_1_1Additional_1_1Vector3d.html">SimpleVoxelEngine::Additional::Vector3d</a>&lt; int &gt; vect)</td></tr>
<tr class="memdesc:a0175d4bc32120485fc72bd914d8eaa99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Проверка существования чанка в памяти.  <a href="#a0175d4bc32120485fc72bd914d8eaa99">Подробнее...</a><br /></td></tr>
<tr class="separator:a0175d4bc32120485fc72bd914d8eaa99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d4fa94e5c312824bd5774d03e5b00b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1Engine.html">Engine</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1World.html#ab9d4fa94e5c312824bd5774d03e5b00b">getEngine</a> ()</td></tr>
<tr class="memdesc:ab9d4fa94e5c312824bd5774d03e5b00b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получение движка.  <a href="#ab9d4fa94e5c312824bd5774d03e5b00b">Подробнее...</a><br /></td></tr>
<tr class="separator:ab9d4fa94e5c312824bd5774d03e5b00b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7fd4a3de91572db3bee5e0c484d5e19"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1World.html#aa7fd4a3de91572db3bee5e0c484d5e19">generateChunk</a> (<a class="el" href="classSimpleVoxelEngine_1_1Additional_1_1Vector3d.html">SimpleVoxelEngine::Additional::Vector3d</a>&lt; int &gt; vect)</td></tr>
<tr class="memdesc:aa7fd4a3de91572db3bee5e0c484d5e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Генерация чанка.  <a href="#aa7fd4a3de91572db3bee5e0c484d5e19">Подробнее...</a><br /></td></tr>
<tr class="separator:aa7fd4a3de91572db3bee5e0c484d5e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67283be3f45257d1e0c474c563ebb6b6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1World.html#a67283be3f45257d1e0c474c563ebb6b6">getId</a> ()</td></tr>
<tr class="memdesc:a67283be3f45257d1e0c474c563ebb6b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получение идентификатора мира.  <a href="#a67283be3f45257d1e0c474c563ebb6b6">Подробнее...</a><br /></td></tr>
<tr class="separator:a67283be3f45257d1e0c474c563ebb6b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86a44c1598234346789a22f9392484ff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1World.html#a86a44c1598234346789a22f9392484ff">setId</a> (int id)</td></tr>
<tr class="memdesc:a86a44c1598234346789a22f9392484ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Установка миру идентификатора.  <a href="#a86a44c1598234346789a22f9392484ff">Подробнее...</a><br /></td></tr>
<tr class="separator:a86a44c1598234346789a22f9392484ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d1fd6b5bf1e55a880989c68224ecd0b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1World.html#a9d1fd6b5bf1e55a880989c68224ecd0b">setWorldGenerator</a> (<a class="el" href="classSimpleVoxelEngine_1_1Core_1_1WorldGenerator.html">SimpleVoxelEngine::Core::WorldGenerator</a> *wrldgen)</td></tr>
<tr class="memdesc:a9d1fd6b5bf1e55a880989c68224ecd0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Установка генератора мира.  <a href="#a9d1fd6b5bf1e55a880989c68224ecd0b">Подробнее...</a><br /></td></tr>
<tr class="separator:a9d1fd6b5bf1e55a880989c68224ecd0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab85e35dd49c0d6cde538de8d2d5de756"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1WorldGenerator.html">SimpleVoxelEngine::Core::WorldGenerator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1World.html#ab85e35dd49c0d6cde538de8d2d5de756">getWorldGenerator</a> ()</td></tr>
<tr class="memdesc:ab85e35dd49c0d6cde538de8d2d5de756"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получение генератора мира.  <a href="#ab85e35dd49c0d6cde538de8d2d5de756">Подробнее...</a><br /></td></tr>
<tr class="separator:ab85e35dd49c0d6cde538de8d2d5de756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c998f3a78d90fd36315b0ef6fabf8ea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1World.html#a1c998f3a78d90fd36315b0ef6fabf8ea">getSizeChunk</a> ()</td></tr>
<tr class="memdesc:a1c998f3a78d90fd36315b0ef6fabf8ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получение размера ребра чанка.  <a href="#a1c998f3a78d90fd36315b0ef6fabf8ea">Подробнее...</a><br /></td></tr>
<tr class="separator:a1c998f3a78d90fd36315b0ef6fabf8ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1900610d55945da647bf5e4011234574"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1VoxelAddress.html">SimpleVoxelEngine::Core::VoxelAddress</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1World.html#a1900610d55945da647bf5e4011234574">getAddressSimpleVoxelObjectByShift</a> (<a class="el" href="classSimpleVoxelEngine_1_1Core_1_1VoxelAddress.html">VoxelAddress</a> *addr, <a class="el" href="classSimpleVoxelEngine_1_1Additional_1_1Vector3d.html">SimpleVoxelEngine::Additional::Vector3d</a>&lt; int &gt; vect)</td></tr>
<tr class="memdesc:a1900610d55945da647bf5e4011234574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получение адреса SimpleVoxelObject по сдвигу.  <a href="#a1900610d55945da647bf5e4011234574">Подробнее...</a><br /></td></tr>
<tr class="separator:a1900610d55945da647bf5e4011234574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15d69848427baad485d373571a17c99f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1World.html#a15d69848427baad485d373571a17c99f">setSimpleVoxelObjectTransparentTester</a> (<a class="el" href="classSimpleVoxelEngine_1_1Core_1_1SimpleVoxelObjectTransparentTester.html">SimpleVoxelObjectTransparentTester</a> *svott)</td></tr>
<tr class="memdesc:a15d69848427baad485d373571a17c99f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Установка контроллера прозрачности.  <a href="#a15d69848427baad485d373571a17c99f">Подробнее...</a><br /></td></tr>
<tr class="separator:a15d69848427baad485d373571a17c99f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9783213c149a44cb36a1b8cb1bb45e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1SimpleVoxelObjectTransparentTester.html">SimpleVoxelObjectTransparentTester</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1World.html#ad9783213c149a44cb36a1b8cb1bb45e7">getSimpleVoxelObjectTransparentTester</a> ()</td></tr>
<tr class="memdesc:ad9783213c149a44cb36a1b8cb1bb45e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получение контроллера прозрачности.  <a href="#ad9783213c149a44cb36a1b8cb1bb45e7">Подробнее...</a><br /></td></tr>
<tr class="separator:ad9783213c149a44cb36a1b8cb1bb45e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e03a0fd1060fe53e93a86b46aa3cf0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1World.html#a10e03a0fd1060fe53e93a86b46aa3cf0">isTransparent</a> (<a class="el" href="classSimpleVoxelEngine_1_1Core_1_1VoxelAddress.html">VoxelAddress</a> *addr, <a class="el" href="classSimpleVoxelEngine_1_1Voxels_1_1SimpleVoxelObject.html">SimpleVoxelEngine::Voxels::SimpleVoxelObject</a> *parent=0)</td></tr>
<tr class="memdesc:a10e03a0fd1060fe53e93a86b46aa3cf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Проверка на прозрачность по <a class="el" href="classSimpleVoxelEngine_1_1Core_1_1VoxelAddress.html" title="Адрес вокселя. ">VoxelAddress</a>.  <a href="#a10e03a0fd1060fe53e93a86b46aa3cf0">Подробнее...</a><br /></td></tr>
<tr class="separator:a10e03a0fd1060fe53e93a86b46aa3cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dceb40809f4346e969cd7304876949e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1VoxelAddress.html">SimpleVoxelEngine::Core::VoxelAddress</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1World.html#a8dceb40809f4346e969cd7304876949e">getAddressSimpleVoxelObjectByThreePoints</a> (<a class="el" href="classSimpleVoxelEngine_1_1Additional_1_1Vector3d.html">SimpleVoxelEngine::Additional::Vector3d</a>&lt; float &gt; v1, <a class="el" href="classSimpleVoxelEngine_1_1Additional_1_1Vector3d.html">SimpleVoxelEngine::Additional::Vector3d</a>&lt; float &gt; v2, <a class="el" href="classSimpleVoxelEngine_1_1Additional_1_1Vector3d.html">SimpleVoxelEngine::Additional::Vector3d</a>&lt; float &gt; v3, float scale, <a class="el" href="classSimpleVoxelEngine_1_1Additional_1_1Vector3d.html">SimpleVoxelEngine::Additional::Vector3d</a>&lt; float &gt; lookvect, <a class="el" href="namespaceSimpleVoxelEngine_1_1Defines.html#a9955cd2aec50d17a34912469f987a59f">SimpleVoxelEngine::Defines::LevelSearchSimpleVoxelObject</a> lssvo=<a class="el" href="namespaceSimpleVoxelEngine_1_1Defines.html#a9955cd2aec50d17a34912469f987a59fa63e09ab5d8bccdea779253793016c553">SimpleVoxelEngine::Defines::LASTLEVEL</a>, int level=1)</td></tr>
<tr class="memdesc:a8dceb40809f4346e969cd7304876949e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получение адреса SimpleVoxelObject по трём точкам в пространстве и вектору направления.  <a href="#a8dceb40809f4346e969cd7304876949e">Подробнее...</a><br /></td></tr>
<tr class="separator:a8dceb40809f4346e969cd7304876949e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7f138a17aa0bc303c5df45e836d96e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1World.html#a0a7f138a17aa0bc303c5df45e836d96e">isVisible</a> (<a class="el" href="classSimpleVoxelEngine_1_1Core_1_1VoxelAddress.html">VoxelAddress</a> *addr, bool *renderfaces, <a class="el" href="classSimpleVoxelEngine_1_1Voxels_1_1SimpleVoxelObject.html">SimpleVoxelEngine::Voxels::SimpleVoxelObject</a> *parent=0)</td></tr>
<tr class="memdesc:a0a7f138a17aa0bc303c5df45e836d96e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Проверка на видимость SimpleVoxelObject по <a class="el" href="classSimpleVoxelEngine_1_1Core_1_1VoxelAddress.html" title="Адрес вокселя. ">VoxelAddress</a>.  <a href="#a0a7f138a17aa0bc303c5df45e836d96e">Подробнее...</a><br /></td></tr>
<tr class="separator:a0a7f138a17aa0bc303c5df45e836d96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae77be643611043f701eb80da7d2595d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimpleVoxelEngine_1_1Additional_1_1Vector3d.html">Additional::Vector3d</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1World.html#ae77be643611043f701eb80da7d2595d4">getPosition</a> (<a class="el" href="classSimpleVoxelEngine_1_1Core_1_1VoxelAddress.html">VoxelAddress</a> *addr, float posscale=1)</td></tr>
<tr class="memdesc:ae77be643611043f701eb80da7d2595d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получение вектора позиции в глобальных мировых координатах SimpleVoxelObjects по <a class="el" href="classSimpleVoxelEngine_1_1Core_1_1VoxelAddress.html" title="Адрес вокселя. ">VoxelAddress</a>.  <a href="#ae77be643611043f701eb80da7d2595d4">Подробнее...</a><br /></td></tr>
<tr class="separator:ae77be643611043f701eb80da7d2595d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a552de469432ee03f3ec302d6ea0b93cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimpleVoxelEngine_1_1Additional_1_1Vector3d.html">Additional::Vector3d</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1World.html#a552de469432ee03f3ec302d6ea0b93cb">getRotation</a> (<a class="el" href="classSimpleVoxelEngine_1_1Core_1_1VoxelAddress.html">VoxelAddress</a> *addr, float rotscale=1)</td></tr>
<tr class="memdesc:a552de469432ee03f3ec302d6ea0b93cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получение вектора поворота в глобальных мировых координатах SimpleVoxelObjects по <a class="el" href="classSimpleVoxelEngine_1_1Core_1_1VoxelAddress.html" title="Адрес вокселя. ">VoxelAddress</a>.  <a href="#a552de469432ee03f3ec302d6ea0b93cb">Подробнее...</a><br /></td></tr>
<tr class="separator:a552de469432ee03f3ec302d6ea0b93cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0024608e4764c87efe8607a77c6441ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimpleVoxelEngine_1_1Additional_1_1Vector3d.html">Additional::Vector3d</a>&lt; float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1World.html#a0024608e4764c87efe8607a77c6441ec">getScale</a> (<a class="el" href="classSimpleVoxelEngine_1_1Core_1_1VoxelAddress.html">VoxelAddress</a> *addr, float scscale=1)</td></tr>
<tr class="memdesc:a0024608e4764c87efe8607a77c6441ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получение вектора масштабирования в глобальных мировых координатах SimpleVoxelObjects по <a class="el" href="classSimpleVoxelEngine_1_1Core_1_1VoxelAddress.html" title="Адрес вокселя. ">VoxelAddress</a>.  <a href="#a0024608e4764c87efe8607a77c6441ec">Подробнее...</a><br /></td></tr>
<tr class="separator:a0024608e4764c87efe8607a77c6441ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcb1e2be7781c0c8fd5cb632e587ed87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1World.html#adcb1e2be7781c0c8fd5cb632e587ed87">setMultiplePartition</a> (bool multpart)</td></tr>
<tr class="memdesc:adcb1e2be7781c0c8fd5cb632e587ed87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Установка типа разбиения чанков.  <a href="#adcb1e2be7781c0c8fd5cb632e587ed87">Подробнее...</a><br /></td></tr>
<tr class="separator:adcb1e2be7781c0c8fd5cb632e587ed87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6668dc8f693d0024df92a45fb759ea8c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1World.html#a6668dc8f693d0024df92a45fb759ea8c">isMultiplePartition</a> ()</td></tr>
<tr class="memdesc:a6668dc8f693d0024df92a45fb759ea8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Проверка на тип разбиения.  <a href="#a6668dc8f693d0024df92a45fb759ea8c">Подробнее...</a><br /></td></tr>
<tr class="separator:a6668dc8f693d0024df92a45fb759ea8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d27a40373e1c936f69a315998cdc8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1World.html#a38d27a40373e1c936f69a315998cdc8d">setChunksSaveLoadController</a> (<a class="el" href="classSimpleVoxelEngine_1_1Core_1_1ChunksSaveLoadController.html">SimpleVoxelEngine::Core::ChunksSaveLoadController</a> *cslc)</td></tr>
<tr class="memdesc:a38d27a40373e1c936f69a315998cdc8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Установка контроллера загрузки и сохранения чанков.  <a href="#a38d27a40373e1c936f69a315998cdc8d">Подробнее...</a><br /></td></tr>
<tr class="separator:a38d27a40373e1c936f69a315998cdc8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83c5eb2a160ac22aedc787c107b3ab12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1ChunksSaveLoadController.html">SimpleVoxelEngine::Core::ChunksSaveLoadController</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1World.html#a83c5eb2a160ac22aedc787c107b3ab12">getChunksSaveLoadController</a> ()</td></tr>
<tr class="memdesc:a83c5eb2a160ac22aedc787c107b3ab12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получение контроллера загрузки и сохранения чанков.  <a href="#a83c5eb2a160ac22aedc787c107b3ab12">Подробнее...</a><br /></td></tr>
<tr class="separator:a83c5eb2a160ac22aedc787c107b3ab12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8bb3912a3ce86b15842e79d0b421204"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1World.html#ac8bb3912a3ce86b15842e79d0b421204">clear</a> ()</td></tr>
<tr class="memdesc:ac8bb3912a3ce86b15842e79d0b421204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Очистка мира.  <a href="#ac8bb3912a3ce86b15842e79d0b421204">Подробнее...</a><br /></td></tr>
<tr class="separator:ac8bb3912a3ce86b15842e79d0b421204"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Подробное описание</h2>
<div class="textblock"><p>Воксельный мир. </p>
<p>Данный класс является регистрируемым воксельным миром. Движок может содержать много воксельных миров. </p>

<p>См. определение в файле <a class="el" href="World_8h_source.html">World.h</a> строка <a class="el" href="World_8h_source.html#l00023">23</a></p>
</div><h2 class="groupheader">Конструктор(ы)</h2>
<a class="anchor" id="a68980dfd830f0fda3be7203b896243ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1World.html">World</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1Engine.html">Engine</a> *&#160;</td>
          <td class="paramname"><em>eng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>folder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>message</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Стандартный конструктор </p>
<p>Сразу загружает мир. </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">eng</td><td>Движок, в котором этот мир зарегистрирован. </td></tr>
    <tr><td class="paramname">folder</td><td>Папка, где будет храниться мир. </td></tr>
    <tr><td class="paramname">message</td><td>Если имеет значение true, то будут поступать сообщения при ошибках во время загрузки мира, иначе не будут. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afa94d10b972c80bec09174fafc1a888f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1World.html">World</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1Engine.html">Engine</a> *&#160;</td>
          <td class="paramname"><em>eng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>folder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizechunk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Конструктор </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">eng</td><td>Движок, в котором этот мир зарегистрирован. </td></tr>
    <tr><td class="paramname">folder</td><td>Папка, где будет храниться мир. </td></tr>
    <tr><td class="paramname">sizechunk</td><td>Размер ребра чанка. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Методы</h2>
<a class="anchor" id="ac8bb3912a3ce86b15842e79d0b421204"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Очистка мира. </p>
<p>Полностью выгружает все чанки из памяти, при этом выполняя сохранение. </p>

</div>
</div>
<a class="anchor" id="a860605dc2663d5a9c66b51f4fb23b67d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool deleteSimpleVoxelObject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1VoxelAddress.html">VoxelAddress</a> *&#160;</td>
          <td class="paramname"><em>addr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Удаление SimpleVoxelObject по <a class="el" href="classSimpleVoxelEngine_1_1Core_1_1VoxelAddress.html" title="Адрес вокселя. ">VoxelAddress</a>. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Адрес вокселя, который надо удалить. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>В случае успеха возвращает true, иначе false. </dd></dl>

</div>
</div>
<a class="anchor" id="aa7fd4a3de91572db3bee5e0c484d5e19"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool generateChunk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimpleVoxelEngine_1_1Additional_1_1Vector3d.html">SimpleVoxelEngine::Additional::Vector3d</a>&lt; int &gt;&#160;</td>
          <td class="paramname"><em>vect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Генерация чанка. </p>
<p>Генерирует чанк с помощью установленного генератора. </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">vect</td><td>Вектор (координаты) генерируемого чанка. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>В случае успеха возвращает true, иначе false. </dd></dl>

</div>
</div>
<a class="anchor" id="a1900610d55945da647bf5e4011234574"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1VoxelAddress.html">SimpleVoxelEngine::Core::VoxelAddress</a>* getAddressSimpleVoxelObjectByShift </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1VoxelAddress.html">VoxelAddress</a> *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimpleVoxelEngine_1_1Additional_1_1Vector3d.html">SimpleVoxelEngine::Additional::Vector3d</a>&lt; int &gt;&#160;</td>
          <td class="paramname"><em>vect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Получение адреса SimpleVoxelObject по сдвигу. </p>
<p>Интеллектуальное определение нового адреса SimpleVoxelObject из сдвига. Учитывает границы чанков. </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Адрес вокселя, от которого идёт сдвиг. </td></tr>
    <tr><td class="paramname">vect</td><td>Вектор сдвига. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает указатель на VoxelAddres. Необходимо удалить самому, когда будет больше не нужен. </dd></dl>

</div>
</div>
<a class="anchor" id="a8dceb40809f4346e969cd7304876949e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1VoxelAddress.html">SimpleVoxelEngine::Core::VoxelAddress</a>* getAddressSimpleVoxelObjectByThreePoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimpleVoxelEngine_1_1Additional_1_1Vector3d.html">SimpleVoxelEngine::Additional::Vector3d</a>&lt; float &gt;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimpleVoxelEngine_1_1Additional_1_1Vector3d.html">SimpleVoxelEngine::Additional::Vector3d</a>&lt; float &gt;&#160;</td>
          <td class="paramname"><em>v2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimpleVoxelEngine_1_1Additional_1_1Vector3d.html">SimpleVoxelEngine::Additional::Vector3d</a>&lt; float &gt;&#160;</td>
          <td class="paramname"><em>v3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimpleVoxelEngine_1_1Additional_1_1Vector3d.html">SimpleVoxelEngine::Additional::Vector3d</a>&lt; float &gt;&#160;</td>
          <td class="paramname"><em>lookvect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceSimpleVoxelEngine_1_1Defines.html#a9955cd2aec50d17a34912469f987a59f">SimpleVoxelEngine::Defines::LevelSearchSimpleVoxelObject</a>&#160;</td>
          <td class="paramname"><em>lssvo</em> = <code><a class="el" href="namespaceSimpleVoxelEngine_1_1Defines.html#a9955cd2aec50d17a34912469f987a59fa63e09ab5d8bccdea779253793016c553">SimpleVoxelEngine::Defines::LASTLEVEL</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>level</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Получение адреса SimpleVoxelObject по трём точкам в пространстве и вектору направления. </p>
<p>Получает адрес SimpleVoxelObject по трём точкам, который он содержит, а также вектору, который в него направлен. </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">v1</td><td>Первая точка. </td></tr>
    <tr><td class="paramname">v2</td><td>Вторая точка. </td></tr>
    <tr><td class="paramname">v3</td><td>Третья точка. </td></tr>
    <tr><td class="paramname">scale</td><td>Масштабирование вокселей в пространстве. </td></tr>
    <tr><td class="paramname">lookvect</td><td>Направление взгляда (вектор, торчащий в воксель). </td></tr>
    <tr><td class="paramname">lssvo</td><td>Тип поиска. Не используется. </td></tr>
    <tr><td class="paramname">level</td><td>Уровень глубины погружения при поиске. Не используется. Весь поиск идёт на первом уровне. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает указатель на <a class="el" href="classSimpleVoxelEngine_1_1Core_1_1VoxelAddress.html" title="Адрес вокселя. ">VoxelAddress</a> объекта SimpleVoxelObject, который содержит три указанных точки, а также вектор направлен в него. </dd></dl>

</div>
</div>
<a class="anchor" id="aef367623a763d208060c6a727169067d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimpleVoxelEngine_1_1Voxels_1_1ChunkVoxelObject.html">SimpleVoxelEngine::Voxels::ChunkVoxelObject</a>* getChunk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimpleVoxelEngine_1_1Additional_1_1Vector3d.html">SimpleVoxelEngine::Additional::Vector3d</a>&lt; int &gt;&#160;</td>
          <td class="paramname"><em>vect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Получение чанка. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">vect</td><td>Вектор (координаты) чанка. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает указатель на чанк с вектором (координатами) vect или NULL в случае неудачи. </dd></dl>

</div>
</div>
<a class="anchor" id="a83c5eb2a160ac22aedc787c107b3ab12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1ChunksSaveLoadController.html">SimpleVoxelEngine::Core::ChunksSaveLoadController</a>* getChunksSaveLoadController </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Получение контроллера загрузки и сохранения чанков. </p>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает указатель на установленный контроллер загрузки и сохранения чанков. </dd></dl>

</div>
</div>
<a class="anchor" id="ab9d4fa94e5c312824bd5774d03e5b00b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1Engine.html">Engine</a>* getEngine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Получение движка. </p>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает указатель на движок, в котором зарегистрирован мир. </dd></dl>

</div>
</div>
<a class="anchor" id="a67283be3f45257d1e0c474c563ebb6b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Получение идентификатора мира. </p>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает идентификатор мира в движке, в котором мир зарегистрирован. Если мир нигде не зарегистрирован, то -1. </dd></dl>

</div>
</div>
<a class="anchor" id="a57a7bf056122dcb7db06ee62603ccfa7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string getNameFolder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Получить имя папки мира. </p>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает имя папки мира. </dd></dl>

</div>
</div>
<a class="anchor" id="ae77be643611043f701eb80da7d2595d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimpleVoxelEngine_1_1Additional_1_1Vector3d.html">Additional::Vector3d</a>&lt;float&gt; getPosition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1VoxelAddress.html">VoxelAddress</a> *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>posscale</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Получение вектора позиции в глобальных мировых координатах SimpleVoxelObjects по <a class="el" href="classSimpleVoxelEngine_1_1Core_1_1VoxelAddress.html" title="Адрес вокселя. ">VoxelAddress</a>. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Адрес SimpleVoxelObject. </td></tr>
    <tr><td class="paramname">posscale</td><td>Масштаб позиции вокселей. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает вектор позиции SimpleVoxelObjects в глобальных координатах. </dd></dl>

</div>
</div>
<a class="anchor" id="a552de469432ee03f3ec302d6ea0b93cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimpleVoxelEngine_1_1Additional_1_1Vector3d.html">Additional::Vector3d</a>&lt;float&gt; getRotation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1VoxelAddress.html">VoxelAddress</a> *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rotscale</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Получение вектора поворота в глобальных мировых координатах SimpleVoxelObjects по <a class="el" href="classSimpleVoxelEngine_1_1Core_1_1VoxelAddress.html" title="Адрес вокселя. ">VoxelAddress</a>. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Адрес SimpleVoxelObject. </td></tr>
    <tr><td class="paramname">rotscale</td><td>Масштаб поворота вокселей. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает вектор поворота SimpleVoxelObjects в глобальных координатах. </dd></dl>

</div>
</div>
<a class="anchor" id="a0024608e4764c87efe8607a77c6441ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimpleVoxelEngine_1_1Additional_1_1Vector3d.html">Additional::Vector3d</a>&lt;float&gt; getScale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1VoxelAddress.html">VoxelAddress</a> *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scscale</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Получение вектора масштабирования в глобальных мировых координатах SimpleVoxelObjects по <a class="el" href="classSimpleVoxelEngine_1_1Core_1_1VoxelAddress.html" title="Адрес вокселя. ">VoxelAddress</a>. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Адрес SimpleVoxelObject. </td></tr>
    <tr><td class="paramname">scscale</td><td>Масштабирование вокселей. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает вектор масштабирования SimpleVoxelObjects в глобальных координатах. </dd></dl>

</div>
</div>
<a class="anchor" id="a9fdfc853c422711e734aaebd4a3efcd7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimpleVoxelEngine_1_1Voxels_1_1SimpleVoxelObject.html">SimpleVoxelEngine::Voxels::SimpleVoxelObject</a>* getSimpleVoxelObject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1VoxelAddress.html">VoxelAddress</a> *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isexists</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Получить SimpleVoxelObject по <a class="el" href="classSimpleVoxelEngine_1_1Core_1_1VoxelAddress.html" title="Адрес вокселя. ">VoxelAddress</a>. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Указатель на <a class="el" href="classSimpleVoxelEngine_1_1Core_1_1VoxelAddress.html" title="Адрес вокселя. ">VoxelAddress</a>. </td></tr>
    <tr><td class="paramname">isexists</td><td>Если имеет значение true, то система логирования выдаст предупреждение при отсутствии SimpleVoxelObject по данному адресу, иначе не выдаст. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает указатель на SimpleVoxelObject или NULL в случае отсутствия SimpleVoxelObject по данному адресу. </dd></dl>

</div>
</div>
<a class="anchor" id="ad9783213c149a44cb36a1b8cb1bb45e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1SimpleVoxelObjectTransparentTester.html">SimpleVoxelObjectTransparentTester</a>* getSimpleVoxelObjectTransparentTester </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Получение контроллера прозрачности. </p>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает указатель на установленный контроллер прозрачности. </dd></dl>

</div>
</div>
<a class="anchor" id="a1c998f3a78d90fd36315b0ef6fabf8ea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int getSizeChunk </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Получение размера ребра чанка. </p>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает размер ребра чанка. </dd></dl>

</div>
</div>
<a class="anchor" id="ab85e35dd49c0d6cde538de8d2d5de756"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1WorldGenerator.html">SimpleVoxelEngine::Core::WorldGenerator</a>* getWorldGenerator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Получение генератора мира. </p>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает указатель на установленный генератор мира. </dd></dl>

</div>
</div>
<a class="anchor" id="a0175d4bc32120485fc72bd914d8eaa99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isExistsChunkInMemory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimpleVoxelEngine_1_1Additional_1_1Vector3d.html">SimpleVoxelEngine::Additional::Vector3d</a>&lt; int &gt;&#160;</td>
          <td class="paramname"><em>vect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Проверка существования чанка в памяти. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">vect</td><td>Вектор (координаты) чанка. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает true, если чанк загружен, иначе false. </dd></dl>

</div>
</div>
<a class="anchor" id="a6668dc8f693d0024df92a45fb759ea8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isMultiplePartition </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Проверка на тип разбиения. </p>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает true, если разбиение всех чанков на всех уровнях одинаково, иначе false. </dd></dl>

</div>
</div>
<a class="anchor" id="a10e03a0fd1060fe53e93a86b46aa3cf0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isTransparent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1VoxelAddress.html">VoxelAddress</a> *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimpleVoxelEngine_1_1Voxels_1_1SimpleVoxelObject.html">SimpleVoxelEngine::Voxels::SimpleVoxelObject</a> *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Проверка на прозрачность по <a class="el" href="classSimpleVoxelEngine_1_1Core_1_1VoxelAddress.html" title="Адрес вокселя. ">VoxelAddress</a>. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Адрес проверяемого вокселя. </td></tr>
    <tr><td class="paramname">parent</td><td>Указатель на SimpleVoxelObject, от которого идёт проверка. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает true, если SimpleVoxelObject по <a class="el" href="classSimpleVoxelEngine_1_1Core_1_1VoxelAddress.html" title="Адрес вокселя. ">VoxelAddress</a> является прозрачным, иначе false. </dd></dl>

</div>
</div>
<a class="anchor" id="a0a7f138a17aa0bc303c5df45e836d96e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool isVisible </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1VoxelAddress.html">VoxelAddress</a> *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>renderfaces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimpleVoxelEngine_1_1Voxels_1_1SimpleVoxelObject.html">SimpleVoxelEngine::Voxels::SimpleVoxelObject</a> *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Проверка на видимость SimpleVoxelObject по <a class="el" href="classSimpleVoxelEngine_1_1Core_1_1VoxelAddress.html" title="Адрес вокселя. ">VoxelAddress</a>. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Указатель на адрес SimpleVoxelObject. </td></tr>
    <tr><td class="paramname">renderfaces</td><td>Массив для заполнения видимости или невидимости граней SimpleVoxelObject. </td></tr>
    <tr><td class="paramname">parent</td><td>Указатель на SimpleVoxelObject, который мы проверяем на видимость. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает true, если SimpleVoxelObject имеет хотя бы одну видимую грань, иначе false. </dd></dl>

</div>
</div>
<a class="anchor" id="a6f1203e5d10c03c78844f334971d7d77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool loadChunk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimpleVoxelEngine_1_1Additional_1_1Vector3d.html">SimpleVoxelEngine::Additional::Vector3d</a>&lt; int &gt;&#160;</td>
          <td class="paramname"><em>vect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Загрузка чанка. </p>
<p>Загружает чанк в память с диска. Если на диске его нет - генерирует с помощью установленного миру генератора. </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">vect</td><td>Вектор (координаты) загружаемого чанка. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает true в случае успеха, иначе false. </dd></dl>

</div>
</div>
<a class="anchor" id="af18015e9bcd1335eba4951f8b359f576"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool loadChunks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimpleVoxelEngine_1_1Additional_1_1Vector3d.html">SimpleVoxelEngine::Additional::Vector3d</a>&lt; int &gt;&#160;</td>
          <td class="paramname"><em>vect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cube_radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Загрузка блока чанков. </p>
<p>Загружает чанки в память с диска. Если на диске каких-то чанков нет - генерирует с помощью установленного миру генератора. Чанки загружается в кубическом радиусе cube_radius от vect. </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">vect</td><td>Вектор (координаты) центра загружаемого куба чанков. </td></tr>
    <tr><td class="paramname">cube_radius</td><td>Кубический радиус. Общий размер куба будет (cube_radius + 1)^3. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает true в случае успеха, иначе false. </dd></dl>

</div>
</div>
<a class="anchor" id="a55172f487483e850285d1bc6b6147fdd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool progressiveLoadChunks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimpleVoxelEngine_1_1Additional_1_1Vector3d.html">SimpleVoxelEngine::Additional::Vector3d</a>&lt; int &gt;&#160;</td>
          <td class="paramname"><em>vect_old</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cube_radius_old</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimpleVoxelEngine_1_1Additional_1_1Vector3d.html">SimpleVoxelEngine::Additional::Vector3d</a>&lt; int &gt;&#160;</td>
          <td class="paramname"><em>vect_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cube_radius_new</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>save</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Интеллектуальная загрузка чанков. </p>
<p>Выгружает чанки из куба с центром в vect_old и радиусом cube_radius_old, которые не лежат в кубе с центром в vect_new радиусом cube_radius_new, потом загружает чанки из куба с центром в vect_new и радиусом cube_radius_new, которые не лежат в кубе с центром vect_old и радиусом cube_radius_old. Уже считается устаревшей и бессмысленной, так как не поддерживает многопоточности ни в каком плане. </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">vect_old</td><td>Центр первого куба. </td></tr>
    <tr><td class="paramname">cube_radius_old</td><td>Радиус первого куба. </td></tr>
    <tr><td class="paramname">vect_new</td><td>Центр второго куба. </td></tr>
    <tr><td class="paramname">cube_radius_new</td><td>Радиус второго куба. </td></tr>
    <tr><td class="paramname">save</td><td>Выполнять ли сохранение выгружаемых чанков. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает true в случае успеха, иначе false. </dd></dl>

</div>
</div>
<a class="anchor" id="a5c2c75cb8bc4d45fcd8cec8b53f7f6f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool saveChunk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimpleVoxelEngine_1_1Additional_1_1Vector3d.html">SimpleVoxelEngine::Additional::Vector3d</a>&lt; int &gt;&#160;</td>
          <td class="paramname"><em>vect</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Сохранение чанка. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">vect</td><td>Вектор (координаты) сохраняемого чанка. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает true в случае успеха, иначе false. </dd></dl>

</div>
</div>
<a class="anchor" id="a30313fd6083b17a7d3d4418cd713a328"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool saveChunks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimpleVoxelEngine_1_1Additional_1_1Vector3d.html">SimpleVoxelEngine::Additional::Vector3d</a>&lt; int &gt;&#160;</td>
          <td class="paramname"><em>vect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cube_radius</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Сохранение чанков. </p>
<p>Сохраняет куб чанков с центром в vect и радиусом cube_radius. </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">vect</td><td>Центр куба. </td></tr>
    <tr><td class="paramname">cube_radius</td><td>Кубический радиус. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает true в случае успеха, иначе false. </dd></dl>

</div>
</div>
<a class="anchor" id="a38d27a40373e1c936f69a315998cdc8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setChunksSaveLoadController </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1ChunksSaveLoadController.html">SimpleVoxelEngine::Core::ChunksSaveLoadController</a> *&#160;</td>
          <td class="paramname"><em>cslc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Установка контроллера загрузки и сохранения чанков. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">cslc</td><td>Указатель на устанавливаемый контроллер загруки и сохранения чанков. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a86a44c1598234346789a22f9392484ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool setId </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Установка миру идентификатора. </p>
<p>Установка идентификатора возможна только один раз. </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Устанавливаемый идентификатор. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>В случае успеха возвращает true, иначе false. </dd></dl>

</div>
</div>
<a class="anchor" id="adcb1e2be7781c0c8fd5cb632e587ed87"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setMultiplePartition </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>multpart</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Установка типа разбиения чанков. </p>
<p>Если имеет значение true, то все чанки имеют одинаковые размеры разбиения на всех уровнях. В этом случае проще поиск вокселей, а так же при рендеринге больше граней отсекаются. </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">multpart</td><td>Значение. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a922cb803428be433e73c597a3893e7c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool setSimpleVoxelObject </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1VoxelAddress.html">SimpleVoxelEngine::Core::VoxelAddress</a> *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSimpleVoxelEngine_1_1Voxels_1_1SimpleVoxelObject.html">SimpleVoxelEngine::Voxels::SimpleVoxelObject</a> *&#160;</td>
          <td class="paramname"><em>svo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rewrite</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Установка SimpleVoxelObject по <a class="el" href="classSimpleVoxelEngine_1_1Core_1_1VoxelAddress.html" title="Адрес вокселя. ">VoxelAddress</a>. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">addr</td><td>Адрес вокселя. </td></tr>
    <tr><td class="paramname">svo</td><td>Устанавливаемый SimpleVoxelObject. </td></tr>
    <tr><td class="paramname">rewrite</td><td>Если имеет значение true, то SimpleVoxelObject будет перезаписан в случае существования. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>В случае успеха возвращает true, иначе false. </dd></dl>

</div>
</div>
<a class="anchor" id="a15d69848427baad485d373571a17c99f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool setSimpleVoxelObjectTransparentTester </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1SimpleVoxelObjectTransparentTester.html">SimpleVoxelObjectTransparentTester</a> *&#160;</td>
          <td class="paramname"><em>svott</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Установка контроллера прозрачности. </p>
<p>Контроллер прозрачности установить можно только один раз. </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">svott</td><td>Указатель на устанавливаемый контроллер прозрачности. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>В случае успеха возвращает true, иначе false. </dd></dl>

</div>
</div>
<a class="anchor" id="a9d1fd6b5bf1e55a880989c68224ecd0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool setWorldGenerator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimpleVoxelEngine_1_1Core_1_1WorldGenerator.html">SimpleVoxelEngine::Core::WorldGenerator</a> *&#160;</td>
          <td class="paramname"><em>wrldgen</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Установка генератора мира. </p>
<p>Возможно установить только один раз. </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">wrldgen</td><td>Указатель на устанавливаемый генератор мира. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>В случае успеха возвращает true, иначе false. </dd></dl>

</div>
</div>
<a class="anchor" id="a95dd9f0d12e78ea10eceeebe8c2da82d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool unloadChunk </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimpleVoxelEngine_1_1Additional_1_1Vector3d.html">SimpleVoxelEngine::Additional::Vector3d</a>&lt; int &gt;&#160;</td>
          <td class="paramname"><em>vect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>save</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>saveplace</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Выгрузка чанка из памяти. </p>
<p>Выгружает чанк vect из памяти. </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">vect</td><td>Вектор (координаты) выгружаемого чанка. </td></tr>
    <tr><td class="paramname">save</td><td>Сохранять ли чанк на диск. </td></tr>
    <tr><td class="paramname">saveplace</td><td>Сохранять ли место в контейнере под чанк. Параметр специфический и только для внутренней работы движка. Использовать не рекомендуется. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает true в случае успеха, иначе false. </dd></dl>

</div>
</div>
<a class="anchor" id="ad0326009a58fd830bd706b38ed2090e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool unloadChunks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSimpleVoxelEngine_1_1Additional_1_1Vector3d.html">SimpleVoxelEngine::Additional::Vector3d</a>&lt; int &gt;&#160;</td>
          <td class="paramname"><em>vect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>cube_radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>save</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Выгрузка чанков из памяти. </p>
<p>Выгружает чанки из куба с центром в vect и радиусом cube_radius из памяти. </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">vect</td><td>Вектор (координаты) выгружаемого чанка. </td></tr>
    <tr><td class="paramname">cube_radius</td><td>Радиус куба. </td></tr>
    <tr><td class="paramname">save</td><td>Сохранять ли чанк на диск. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает true в случае успеха, иначе false. </dd></dl>

</div>
</div>
<a class="anchor" id="a6568f5c99a15e2c9c92cd17ff3da9d2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool writeWorldInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Запись информации о мире на диск. </p>
<p>Записывает в ini-файл мира информацию. </p><dl class="section return"><dt>Возвращает</dt><dd>Возвращает true в случае успеха, иначе false. </dd></dl>

</div>
</div>
<hr/>Объявления и описания членов класса находятся в файле:<ul>
<li><a class="el" href="World_8h_source.html">World.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Документация по SimpleVoxelEngine. Последние изменения: Чт 25 Дек 2014 04:13:21. Создано системой &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
