<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>IrrSimpleVoxelEngine: Класс SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">IrrSimpleVoxelEngine
   &#160;<span id="projectnumber">build 0.0.1</span>
   </div>
   <div id="projectbrief">Враппер для воксельного движка на irrlicht</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Создано системой Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Поиск');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Титульная&#160;страница</span></a></li>
      <li><a href="pages.html"><span>Описания</span></a></li>
      <li><a href="namespaces.html"><span>Пространства&#160;имен</span></a></li>
      <li class="current"><a href="annotated.html"><span>Классы</span></a></li>
      <li><a href="files.html"><span>Файлы</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Поиск" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Классы</span></a></li>
      <li><a href="classes.html"><span>Алфавитный&#160;указатель&#160;классов</span></a></li>
      <li><a href="hierarchy.html"><span>Иерархия&#160;классов</span></a></li>
      <li><a href="functions.html"><span>Члены&#160;классов</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>Указатель</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Классы</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Пространства имен</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Файлы</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Функции</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Переменные</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Перечисления</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Элементы перечислений</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Друзья</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Страницы</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_simple_voxel_engine.html">SimpleVoxelEngine</a></li><li class="navelem"><a class="el" href="namespace_simple_voxel_engine_1_1_irr_engine.html">IrrEngine</a></li><li class="navelem"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html">FactoryChunkMeshSceneNode</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Открытые члены</a> &#124;
<a href="#pro-methods">Защищенные члены</a> &#124;
<a href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node-members.html">Полный список членов класса</a>  </div>
  <div class="headertitle">
<div class="title">Класс SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Фабрика для управления Irrlicht-нодами чанков.  
 <a href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#details">Подробнее...</a></p>

<p><code>#include &lt;<a class="el" href="_factory_chunk_mesh_scene_node_8h_source.html">FactoryChunkMeshSceneNode.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Открытые члены</h2></td></tr>
<tr class="memitem:a872272a40d68e1bd37bf9261f91591cf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#a872272a40d68e1bd37bf9261f91591cf">FactoryChunkMeshSceneNode</a> (irr::IrrlichtDevice *device, <a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_irr_simple_voxel_engine.html">IrrSimpleVoxelEngine</a> *isve)</td></tr>
<tr class="memdesc:a872272a40d68e1bd37bf9261f91591cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Конструктор с параметрами.  <a href="#a872272a40d68e1bd37bf9261f91591cf">Подробнее...</a><br /></td></tr>
<tr class="separator:a872272a40d68e1bd37bf9261f91591cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b46d40a950cd201640c221f17015884"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#a8b46d40a950cd201640c221f17015884">FactoryChunkMeshSceneNode</a> (irr::IrrlichtDevice *device)</td></tr>
<tr class="memdesc:a8b46d40a950cd201640c221f17015884"><td class="mdescLeft">&#160;</td><td class="mdescRight">Конструктор с параметрами.  <a href="#a8b46d40a950cd201640c221f17015884">Подробнее...</a><br /></td></tr>
<tr class="separator:a8b46d40a950cd201640c221f17015884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72267225461352ff2d99342e2b1f9e8b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a72267225461352ff2d99342e2b1f9e8b"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#a72267225461352ff2d99342e2b1f9e8b">FactoryChunkMeshSceneNode</a> ()</td></tr>
<tr class="memdesc:a72267225461352ff2d99342e2b1f9e8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Стандартный конструктор. <br /></td></tr>
<tr class="separator:a72267225461352ff2d99342e2b1f9e8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d85d8c6c6e3b8840f639a9efb651921"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d85d8c6c6e3b8840f639a9efb651921"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#a8d85d8c6c6e3b8840f639a9efb651921">~FactoryChunkMeshSceneNode</a> ()</td></tr>
<tr class="memdesc:a8d85d8c6c6e3b8840f639a9efb651921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Стандартный деструктор. <br /></td></tr>
<tr class="separator:a8d85d8c6c6e3b8840f639a9efb651921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbc7b7dbbecb9bf3c694ba825c865e0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#abbc7b7dbbecb9bf3c694ba825c865e0c">updateChunks</a> (int id)</td></tr>
<tr class="memdesc:abbc7b7dbbecb9bf3c694ba825c865e0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Создание задания на обновление чанков из помеченных на обновление из заданного мира.  <a href="#abbc7b7dbbecb9bf3c694ba825c865e0c">Подробнее...</a><br /></td></tr>
<tr class="separator:abbc7b7dbbecb9bf3c694ba825c865e0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f0f4b1d2c348614da81cc8abeeb9bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#a09f0f4b1d2c348614da81cc8abeeb9bd">updateChunks</a> ()</td></tr>
<tr class="memdesc:a09f0f4b1d2c348614da81cc8abeeb9bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Создание задания на обновление чанков из помеченных на обновление из всех зарегистрированных миров.  <a href="#a09f0f4b1d2c348614da81cc8abeeb9bd">Подробнее...</a><br /></td></tr>
<tr class="separator:a09f0f4b1d2c348614da81cc8abeeb9bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3edc521898539f4e696a14020960e448"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#a3edc521898539f4e696a14020960e448">updateAllChunks</a> (int id)</td></tr>
<tr class="memdesc:a3edc521898539f4e696a14020960e448"><td class="mdescLeft">&#160;</td><td class="mdescRight">Создание задания на обновление всех чанков из заданного мира.  <a href="#a3edc521898539f4e696a14020960e448">Подробнее...</a><br /></td></tr>
<tr class="separator:a3edc521898539f4e696a14020960e448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69580519b23ed6e3513e1be30199330d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#a69580519b23ed6e3513e1be30199330d">updateAllChunks</a> ()</td></tr>
<tr class="memdesc:a69580519b23ed6e3513e1be30199330d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Создание задания на обновление всех чанков из всех зарегистрированных миров.  <a href="#a69580519b23ed6e3513e1be30199330d">Подробнее...</a><br /></td></tr>
<tr class="separator:a69580519b23ed6e3513e1be30199330d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d85216b79da409438ce49eb738e38e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#a10d85216b79da409438ce49eb738e38e">updateChunk</a> (int id, SimpleVoxelEngine::Additional::Vector3d&lt; int &gt; vect, bool saveplace=false)</td></tr>
<tr class="memdesc:a10d85216b79da409438ce49eb738e38e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Создание задания на обновление указанного чанка.  <a href="#a10d85216b79da409438ce49eb738e38e">Подробнее...</a><br /></td></tr>
<tr class="separator:a10d85216b79da409438ce49eb738e38e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda0d00b58fae7bc387bd6c1402ba2a4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#acda0d00b58fae7bc387bd6c1402ba2a4">setChunkForUpdate</a> (int id, SimpleVoxelEngine::Additional::Vector3d&lt; int &gt; vect)</td></tr>
<tr class="memdesc:acda0d00b58fae7bc387bd6c1402ba2a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Пометить чанк для обновления.  <a href="#acda0d00b58fae7bc387bd6c1402ba2a4">Подробнее...</a><br /></td></tr>
<tr class="separator:acda0d00b58fae7bc387bd6c1402ba2a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9a5f7189898833b1184a43854a0a5ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#ac9a5f7189898833b1184a43854a0a5ab">isRenderChunk</a> (int id, SimpleVoxelEngine::Additional::Vector3d&lt; int &gt; vect)</td></tr>
<tr class="memdesc:ac9a5f7189898833b1184a43854a0a5ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Проверка состояния отрисовки чанка.  <a href="#ac9a5f7189898833b1184a43854a0a5ab">Подробнее...</a><br /></td></tr>
<tr class="separator:ac9a5f7189898833b1184a43854a0a5ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af25d330bae3295152c0e25b9f32f8885"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#af25d330bae3295152c0e25b9f32f8885">isForUpdateChunk</a> (int id, SimpleVoxelEngine::Additional::Vector3d&lt; int &gt; vect)</td></tr>
<tr class="memdesc:af25d330bae3295152c0e25b9f32f8885"><td class="mdescLeft">&#160;</td><td class="mdescRight">Проверка состояния пометки для обновления.  <a href="#af25d330bae3295152c0e25b9f32f8885">Подробнее...</a><br /></td></tr>
<tr class="separator:af25d330bae3295152c0e25b9f32f8885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d334f499012d0578745045992e42818"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#a6d334f499012d0578745045992e42818">addChunk</a> (int id, SimpleVoxelEngine::Additional::Vector3d&lt; int &gt; vect, SimpleVoxelEngine::Voxels::ChunkVoxelObject *cvo)</td></tr>
<tr class="memdesc:a6d334f499012d0578745045992e42818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Низкоуровневая функция добавления чанка.  <a href="#a6d334f499012d0578745045992e42818">Подробнее...</a><br /></td></tr>
<tr class="separator:a6d334f499012d0578745045992e42818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c39f400eb370453b7dc7b8d20a411ef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#a8c39f400eb370453b7dc7b8d20a411ef">deleteChunk</a> (int id, SimpleVoxelEngine::Additional::Vector3d&lt; int &gt; vect)</td></tr>
<tr class="memdesc:a8c39f400eb370453b7dc7b8d20a411ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Удаление указанного чанка.  <a href="#a8c39f400eb370453b7dc7b8d20a411ef">Подробнее...</a><br /></td></tr>
<tr class="separator:a8c39f400eb370453b7dc7b8d20a411ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f106aa604c5cee5dfb7aa64ff796787"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#a2f106aa604c5cee5dfb7aa64ff796787">deleteAllChunks</a> (int id)</td></tr>
<tr class="memdesc:a2f106aa604c5cee5dfb7aa64ff796787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Удаление всех чанков из указанного мира.  <a href="#a2f106aa604c5cee5dfb7aa64ff796787">Подробнее...</a><br /></td></tr>
<tr class="separator:a2f106aa604c5cee5dfb7aa64ff796787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e8184b6b6f6a75e0b5716e3980a3c52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#a1e8184b6b6f6a75e0b5716e3980a3c52">deleteAllChunks</a> ()</td></tr>
<tr class="memdesc:a1e8184b6b6f6a75e0b5716e3980a3c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Удаляение всех чанков.  <a href="#a1e8184b6b6f6a75e0b5716e3980a3c52">Подробнее...</a><br /></td></tr>
<tr class="separator:a1e8184b6b6f6a75e0b5716e3980a3c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4a160995951cb37c9e13e6a55d2173"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#a4d4a160995951cb37c9e13e6a55d2173">freeze</a> ()</td></tr>
<tr class="memdesc:a4d4a160995951cb37c9e13e6a55d2173"><td class="mdescLeft">&#160;</td><td class="mdescRight">Заморозка фабрики.  <a href="#a4d4a160995951cb37c9e13e6a55d2173">Подробнее...</a><br /></td></tr>
<tr class="separator:a4d4a160995951cb37c9e13e6a55d2173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cf68b66c7425b4d56322089f5f1fe17"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#a1cf68b66c7425b4d56322089f5f1fe17">isFreeze</a> ()</td></tr>
<tr class="memdesc:a1cf68b66c7425b4d56322089f5f1fe17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Проверка состояния заморозки фабрики.  <a href="#a1cf68b66c7425b4d56322089f5f1fe17">Подробнее...</a><br /></td></tr>
<tr class="separator:a1cf68b66c7425b4d56322089f5f1fe17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f63e6aea079a265afed4bb57b091a89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_irr_simple_voxel_engine.html">IrrSimpleVoxelEngine</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#a6f63e6aea079a265afed4bb57b091a89">getIrrSimpleVoxelEngine</a> ()</td></tr>
<tr class="memdesc:a6f63e6aea079a265afed4bb57b091a89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получение указателя на используемый враппер.  <a href="#a6f63e6aea079a265afed4bb57b091a89">Подробнее...</a><br /></td></tr>
<tr class="separator:a6f63e6aea079a265afed4bb57b091a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01547050ddd128ad7ac64f5384d84fc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#af01547050ddd128ad7ac64f5384d84fc">setIrrSimpleVoxelEngine</a> (<a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_irr_simple_voxel_engine.html">IrrSimpleVoxelEngine</a> *isve)</td></tr>
<tr class="memdesc:af01547050ddd128ad7ac64f5384d84fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Установка используемого враппера.  <a href="#af01547050ddd128ad7ac64f5384d84fc">Подробнее...</a><br /></td></tr>
<tr class="separator:af01547050ddd128ad7ac64f5384d84fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b4d6d07ee7273837f198cd0776395c1"><td class="memItemLeft" align="right" valign="top">irr::IrrlichtDevice *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#a3b4d6d07ee7273837f198cd0776395c1">getIrrlichtDevice</a> ()</td></tr>
<tr class="memdesc:a3b4d6d07ee7273837f198cd0776395c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получение указателя на IrrlichtDevice, используемый для отрисовки.  <a href="#a3b4d6d07ee7273837f198cd0776395c1">Подробнее...</a><br /></td></tr>
<tr class="separator:a3b4d6d07ee7273837f198cd0776395c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a867afc5632aa9557c20778b694051882"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#a867afc5632aa9557c20778b694051882">setIrrlichtDevice</a> (irr::IrrlichtDevice *device)</td></tr>
<tr class="memdesc:a867afc5632aa9557c20778b694051882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Установка IrrlichtDevice для отрисовки.  <a href="#a867afc5632aa9557c20778b694051882">Подробнее...</a><br /></td></tr>
<tr class="separator:a867afc5632aa9557c20778b694051882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b6a821b0af08b24033e1d37127f075d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#a6b6a821b0af08b24033e1d37127f075d">clear</a> ()</td></tr>
<tr class="memdesc:a6b6a821b0af08b24033e1d37127f075d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Полная очистка фабрики.  <a href="#a6b6a821b0af08b24033e1d37127f075d">Подробнее...</a><br /></td></tr>
<tr class="separator:a6b6a821b0af08b24033e1d37127f075d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ecbc0d9fe64b98eae06cae52c030554"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#a4ecbc0d9fe64b98eae06cae52c030554">setPositionScale</a> (float ps)</td></tr>
<tr class="memdesc:a4ecbc0d9fe64b98eae06cae52c030554"><td class="mdescLeft">&#160;</td><td class="mdescRight">Установка масштаба позиции.  <a href="#a4ecbc0d9fe64b98eae06cae52c030554">Подробнее...</a><br /></td></tr>
<tr class="separator:a4ecbc0d9fe64b98eae06cae52c030554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e8a49110d031739b6882018ba186f4"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#a82e8a49110d031739b6882018ba186f4">getPositionScale</a> ()</td></tr>
<tr class="memdesc:a82e8a49110d031739b6882018ba186f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получение масштаба позиции.  <a href="#a82e8a49110d031739b6882018ba186f4">Подробнее...</a><br /></td></tr>
<tr class="separator:a82e8a49110d031739b6882018ba186f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b0e22b06a466dbcb725cf88f42dcef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#a76b0e22b06a466dbcb725cf88f42dcef">setRotationScale</a> (float rs)</td></tr>
<tr class="memdesc:a76b0e22b06a466dbcb725cf88f42dcef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Установка масштаба поворота.  <a href="#a76b0e22b06a466dbcb725cf88f42dcef">Подробнее...</a><br /></td></tr>
<tr class="separator:a76b0e22b06a466dbcb725cf88f42dcef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e0cc1a4ca98454a4e55228b51bffce"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#ad8e0cc1a4ca98454a4e55228b51bffce">getRotationScale</a> ()</td></tr>
<tr class="memdesc:ad8e0cc1a4ca98454a4e55228b51bffce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получение масштаба поворота.  <a href="#ad8e0cc1a4ca98454a4e55228b51bffce">Подробнее...</a><br /></td></tr>
<tr class="separator:ad8e0cc1a4ca98454a4e55228b51bffce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac28982234390cbf99bbd1bea12e508b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#ac28982234390cbf99bbd1bea12e508b7">setSScale</a> (float ss)</td></tr>
<tr class="memdesc:ac28982234390cbf99bbd1bea12e508b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Установка масштаба масштабирования.  <a href="#ac28982234390cbf99bbd1bea12e508b7">Подробнее...</a><br /></td></tr>
<tr class="separator:ac28982234390cbf99bbd1bea12e508b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab090150e96dc7024356301b9b4598787"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#ab090150e96dc7024356301b9b4598787">getSScale</a> ()</td></tr>
<tr class="memdesc:ab090150e96dc7024356301b9b4598787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получение масштаба масштабирования.  <a href="#ab090150e96dc7024356301b9b4598787">Подробнее...</a><br /></td></tr>
<tr class="separator:ab090150e96dc7024356301b9b4598787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf2e165d34e4916e4c813332b5e9466"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#a8bf2e165d34e4916e4c813332b5e9466">setIsFaces</a> (bool value)</td></tr>
<tr class="memdesc:a8bf2e165d34e4916e4c813332b5e9466"><td class="mdescLeft">&#160;</td><td class="mdescRight">Установка получения при отрисовке чанков информации о видимых гранях.  <a href="#a8bf2e165d34e4916e4c813332b5e9466">Подробнее...</a><br /></td></tr>
<tr class="separator:a8bf2e165d34e4916e4c813332b5e9466"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdeaa66b13e2753b3129ffa0da6affe9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#abdeaa66b13e2753b3129ffa0da6affe9">isFaces</a> ()</td></tr>
<tr class="memdesc:abdeaa66b13e2753b3129ffa0da6affe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получение состояния получения информации о видимых гранях.  <a href="#abdeaa66b13e2753b3129ffa0da6affe9">Подробнее...</a><br /></td></tr>
<tr class="separator:abdeaa66b13e2753b3129ffa0da6affe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39838272d8e9c3183eb50ad447a24b16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#a39838272d8e9c3183eb50ad447a24b16">setMultiplePartition</a> (int id, bool mp)</td></tr>
<tr class="memdesc:a39838272d8e9c3183eb50ad447a24b16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Установка типа разбиения чанков.  <a href="#a39838272d8e9c3183eb50ad447a24b16">Подробнее...</a><br /></td></tr>
<tr class="separator:a39838272d8e9c3183eb50ad447a24b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c37ea4edd78bb64a691cc00b9a09402"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#a6c37ea4edd78bb64a691cc00b9a09402">isMultiplePartition</a> (int id)</td></tr>
<tr class="memdesc:a6c37ea4edd78bb64a691cc00b9a09402"><td class="mdescLeft">&#160;</td><td class="mdescRight">Проверка на тип разбиения.  <a href="#a6c37ea4edd78bb64a691cc00b9a09402">Подробнее...</a><br /></td></tr>
<tr class="separator:a6c37ea4edd78bb64a691cc00b9a09402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e022418d14e9f06d2dfe33173bb81c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#a2e022418d14e9f06d2dfe33173bb81c5">updateMeshChunks</a> ()</td></tr>
<tr class="memdesc:a2e022418d14e9f06d2dfe33173bb81c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Обновление мешей чанков.  <a href="#a2e022418d14e9f06d2dfe33173bb81c5">Подробнее...</a><br /></td></tr>
<tr class="separator:a2e022418d14e9f06d2dfe33173bb81c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f11bfe48793212e75b088203e9ac2c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#a59f11bfe48793212e75b088203e9ac2c">updateMeshChunks</a> (int numbermesh)</td></tr>
<tr class="memdesc:a59f11bfe48793212e75b088203e9ac2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Обновление мешей чанков только на заданном уровне.  <a href="#a59f11bfe48793212e75b088203e9ac2c">Подробнее...</a><br /></td></tr>
<tr class="separator:a59f11bfe48793212e75b088203e9ac2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97bacb0a9a0c4331ecf199b7101d1854"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#a97bacb0a9a0c4331ecf199b7101d1854">updateMeshChunksByWorldId</a> (int id)</td></tr>
<tr class="memdesc:a97bacb0a9a0c4331ecf199b7101d1854"><td class="mdescLeft">&#160;</td><td class="mdescRight">Обновление мешей чанков в заданном мире.  <a href="#a97bacb0a9a0c4331ecf199b7101d1854">Подробнее...</a><br /></td></tr>
<tr class="separator:a97bacb0a9a0c4331ecf199b7101d1854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b3dbb84aa7bf1b095002698d103c69d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#a0b3dbb84aa7bf1b095002698d103c69d">updateMeshChunksByWorldIdAndVector</a> (int id, SimpleVoxelEngine::Additional::Vector3d&lt; int &gt; vect)</td></tr>
<tr class="memdesc:a0b3dbb84aa7bf1b095002698d103c69d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Обновление меша заданного чанка в заданном мире.  <a href="#a0b3dbb84aa7bf1b095002698d103c69d">Подробнее...</a><br /></td></tr>
<tr class="separator:a0b3dbb84aa7bf1b095002698d103c69d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3841b85da31be2ff7eb6113cece5b626"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#a3841b85da31be2ff7eb6113cece5b626">updateMeshChunks</a> (int numbermesh, int id)</td></tr>
<tr class="memdesc:a3841b85da31be2ff7eb6113cece5b626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Обновление мешей чанков в заданном мире только на заданном уровне.  <a href="#a3841b85da31be2ff7eb6113cece5b626">Подробнее...</a><br /></td></tr>
<tr class="separator:a3841b85da31be2ff7eb6113cece5b626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e691b2568ddf7d0b70ee3c03252832d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#a0e691b2568ddf7d0b70ee3c03252832d">updateMeshChunk</a> (int numbermesh, int id, SimpleVoxelEngine::Additional::Vector3d&lt; int &gt; vect)</td></tr>
<tr class="memdesc:a0e691b2568ddf7d0b70ee3c03252832d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Обновление меша заданного чанка в заданном мире только на заданном уровне.  <a href="#a0e691b2568ddf7d0b70ee3c03252832d">Подробнее...</a><br /></td></tr>
<tr class="separator:a0e691b2568ddf7d0b70ee3c03252832d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa95296d1a3a9cea643ec22ca83c9d7b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#aa95296d1a3a9cea643ec22ca83c9d7b4">updateMeshChunk</a> (int id, SimpleVoxelEngine::Additional::Vector3d&lt; int &gt; vect)</td></tr>
<tr class="memdesc:aa95296d1a3a9cea643ec22ca83c9d7b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Обновление меша заданного чанка в заданном мире.  <a href="#aa95296d1a3a9cea643ec22ca83c9d7b4">Подробнее...</a><br /></td></tr>
<tr class="separator:aa95296d1a3a9cea643ec22ca83c9d7b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a7b3250fc857a8991d06ec5ece727f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#ac1a7b3250fc857a8991d06ec5ece727f">update</a> ()</td></tr>
<tr class="memdesc:ac1a7b3250fc857a8991d06ec5ece727f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Главная функция, отвечающая за работу фабрики.  <a href="#ac1a7b3250fc857a8991d06ec5ece727f">Подробнее...</a><br /></td></tr>
<tr class="separator:ac1a7b3250fc857a8991d06ec5ece727f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d0bb1e5704dae48325e3cfb7d602b5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#a5d0bb1e5704dae48325e3cfb7d602b5c">setSizeBlockChunks</a> (int id, int xsize, int ysize, int zsize)</td></tr>
<tr class="memdesc:a5d0bb1e5704dae48325e3cfb7d602b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Установка кубоида для объединения чанков в один меш.  <a href="#a5d0bb1e5704dae48325e3cfb7d602b5c">Подробнее...</a><br /></td></tr>
<tr class="separator:a5d0bb1e5704dae48325e3cfb7d602b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1607b8c31f317c7501261dfd7c2db4d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#a1607b8c31f317c7501261dfd7c2db4d9">setSizeBlockChunks</a> (int xsize, int ysize, int zsize)</td></tr>
<tr class="memdesc:a1607b8c31f317c7501261dfd7c2db4d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Установка кубоида для объединения чанков в один меш по умолчанию.  <a href="#a1607b8c31f317c7501261dfd7c2db4d9">Подробнее...</a><br /></td></tr>
<tr class="separator:a1607b8c31f317c7501261dfd7c2db4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4fffee34ecf5afae1c7624d6877eb6b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#af4fffee34ecf5afae1c7624d6877eb6b">setOcclusionQueries</a> (bool value)</td></tr>
<tr class="memdesc:af4fffee34ecf5afae1c7624d6877eb6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Установка Occlusion Queries.  <a href="#af4fffee34ecf5afae1c7624d6877eb6b">Подробнее...</a><br /></td></tr>
<tr class="separator:af4fffee34ecf5afae1c7624d6877eb6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04386415b4c6a0190972668fe56e3441"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#a04386415b4c6a0190972668fe56e3441">getOcclusionQueries</a> ()</td></tr>
<tr class="memdesc:a04386415b4c6a0190972668fe56e3441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получение состояния Occlusion Queries.  <a href="#a04386415b4c6a0190972668fe56e3441">Подробнее...</a><br /></td></tr>
<tr class="separator:a04386415b4c6a0190972668fe56e3441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913a15c86b99563055ec0c320ceff423"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#a913a15c86b99563055ec0c320ceff423">setTimerTestOcclusionQueriesInMilliseconds</a> (unsigned int timer)</td></tr>
<tr class="memdesc:a913a15c86b99563055ec0c320ceff423"><td class="mdescLeft">&#160;</td><td class="mdescRight">Установка таймера пересчёта Occlusion Queries.  <a href="#a913a15c86b99563055ec0c320ceff423">Подробнее...</a><br /></td></tr>
<tr class="separator:a913a15c86b99563055ec0c320ceff423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c739f5e8224b2f09571db04113f3f70"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#a1c739f5e8224b2f09571db04113f3f70">getTimerTestOcclusionQueriesInMilliseconds</a> ()</td></tr>
<tr class="memdesc:a1c739f5e8224b2f09571db04113f3f70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получение значения таймера Occlusion Queries.  <a href="#a1c739f5e8224b2f09571db04113f3f70">Подробнее...</a><br /></td></tr>
<tr class="separator:a1c739f5e8224b2f09571db04113f3f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9de19a98a848a6e573157353d5d6d0ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#a9de19a98a848a6e573157353d5d6d0ed">setMaterialFlag</a> (int numbermesh, int id, irr::video::E_MATERIAL_FLAG flag, bool value)</td></tr>
<tr class="memdesc:a9de19a98a848a6e573157353d5d6d0ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Установка флага материала.  <a href="#a9de19a98a848a6e573157353d5d6d0ed">Подробнее...</a><br /></td></tr>
<tr class="separator:a9de19a98a848a6e573157353d5d6d0ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a768bbf1d6e6599220c98e05fa998efd9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#a768bbf1d6e6599220c98e05fa998efd9">setHardwareMappingHint</a> (int numbermesh, irr::scene::E_HARDWARE_MAPPING mapping, irr::scene::E_BUFFER_TYPE buffertype)</td></tr>
<tr class="memdesc:a768bbf1d6e6599220c98e05fa998efd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Установка hardware mapping hint для всех чанков на указанном уровне по умолчанию.  <a href="#a768bbf1d6e6599220c98e05fa998efd9">Подробнее...</a><br /></td></tr>
<tr class="separator:a768bbf1d6e6599220c98e05fa998efd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ccd73bfa1c8b3d232d3105470d56bd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#a3ccd73bfa1c8b3d232d3105470d56bd8">setHardwareMappingHint</a> (int numbermesh, int id, irr::scene::E_HARDWARE_MAPPING mapping, irr::scene::E_BUFFER_TYPE buffertype)</td></tr>
<tr class="memdesc:a3ccd73bfa1c8b3d232d3105470d56bd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Установка hardware mapping hint для всех чанков на указанном уровне данному миру.  <a href="#a3ccd73bfa1c8b3d232d3105470d56bd8">Подробнее...</a><br /></td></tr>
<tr class="separator:a3ccd73bfa1c8b3d232d3105470d56bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9177a4a69c056fd5273f80ff5fc28c71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#a9177a4a69c056fd5273f80ff5fc28c71">setMaterialType</a> (int numbermesh, irr::video::E_MATERIAL_TYPE newtype)</td></tr>
<tr class="memdesc:a9177a4a69c056fd5273f80ff5fc28c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Установка типа материала на указанном уровне для всех чанков на указанном уровне по умолчанию.  <a href="#a9177a4a69c056fd5273f80ff5fc28c71">Подробнее...</a><br /></td></tr>
<tr class="separator:a9177a4a69c056fd5273f80ff5fc28c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbc5184569b3b8685808d11747e281f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#afbc5184569b3b8685808d11747e281f0">setMaterialType</a> (int numbermesh, int id, irr::video::E_MATERIAL_TYPE newtype)</td></tr>
<tr class="memdesc:afbc5184569b3b8685808d11747e281f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Установка типа материала на указанном уровне для всех чанков на указанном уровне данному миру.  <a href="#afbc5184569b3b8685808d11747e281f0">Подробнее...</a><br /></td></tr>
<tr class="separator:afbc5184569b3b8685808d11747e281f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71953494b410b0581669891fda1e5002"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#a71953494b410b0581669891fda1e5002">setID</a> (int numbermesh, int id, irr::s32 idscenenode)</td></tr>
<tr class="memdesc:a71953494b410b0581669891fda1e5002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Установка ID чанков в указанном мире на указанном уровне.  <a href="#a71953494b410b0581669891fda1e5002">Подробнее...</a><br /></td></tr>
<tr class="separator:a71953494b410b0581669891fda1e5002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6502e3f66ddf9e29f0fb34cd3436294f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#a6502e3f66ddf9e29f0fb34cd3436294f">setNumberOfMeshesSceneNodeForChunk</a> (int nomsnfc)</td></tr>
<tr class="memdesc:a6502e3f66ddf9e29f0fb34cd3436294f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Установка количества мешей одному чанку.  <a href="#a6502e3f66ddf9e29f0fb34cd3436294f">Подробнее...</a><br /></td></tr>
<tr class="separator:a6502e3f66ddf9e29f0fb34cd3436294f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51b5b65a39388449a96dbd6f820b8456"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#a51b5b65a39388449a96dbd6f820b8456">getNumberOfMeshesSceneNodeForChunk</a> ()</td></tr>
<tr class="memdesc:a51b5b65a39388449a96dbd6f820b8456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получение числа мешей у одного чанка.  <a href="#a51b5b65a39388449a96dbd6f820b8456">Подробнее...</a><br /></td></tr>
<tr class="separator:a51b5b65a39388449a96dbd6f820b8456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa734bf6f354a56fdcfa07178d99dc610"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#aa734bf6f354a56fdcfa07178d99dc610">updateCameraPosition</a> (int id, irr::core::vector3df vect)</td></tr>
<tr class="memdesc:aa734bf6f354a56fdcfa07178d99dc610"><td class="mdescLeft">&#160;</td><td class="mdescRight">Обновление позиции камеры.  <a href="#aa734bf6f354a56fdcfa07178d99dc610">Подробнее...</a><br /></td></tr>
<tr class="separator:aa734bf6f354a56fdcfa07178d99dc610"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Защищенные члены</h2></td></tr>
<tr class="memitem:ab691e406ad430ecdbca14bbb1934ffec"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#ab691e406ad430ecdbca14bbb1934ffec">onUpdateChunkMeshSceneNode</a> (irr::scene::IMeshSceneNode *node, int numbermesh, SimpleVoxelEngine::Additional::Vector3d&lt; int &gt; vectblock)</td></tr>
<tr class="memdesc:ab691e406ad430ecdbca14bbb1934ffec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Окончательная обработка при обновлении Irrlicht-ноды чанка.  <a href="#ab691e406ad430ecdbca14bbb1934ffec">Подробнее...</a><br /></td></tr>
<tr class="separator:ab691e406ad430ecdbca14bbb1934ffec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27a2334f771987a227e66ccced46ccc2"><td class="memItemLeft" align="right" valign="top">virtual irr::scene::IMesh *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#a27a2334f771987a227e66ccced46ccc2">getMeshVoxel</a> (SimpleVoxelEngine::Core::VoxelForRendering *vxlfr)=0</td></tr>
<tr class="memdesc:a27a2334f771987a227e66ccced46ccc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получение меша вокселя.  <a href="#a27a2334f771987a227e66ccced46ccc2">Подробнее...</a><br /></td></tr>
<tr class="separator:a27a2334f771987a227e66ccced46ccc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4217d3d1c4782246cfa52e923a7651be"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#a4217d3d1c4782246cfa52e923a7651be">getMeshNumber</a> (SimpleVoxelEngine::Core::VoxelForRendering *vxlfr)=0</td></tr>
<tr class="memdesc:a4217d3d1c4782246cfa52e923a7651be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получение информации о номере уровня меша, куда будет вклеиваться воксель.  <a href="#a4217d3d1c4782246cfa52e923a7651be">Подробнее...</a><br /></td></tr>
<tr class="separator:a4217d3d1c4782246cfa52e923a7651be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5717f8fd5450ff34089b4ce89afc444"><td class="memItemLeft" align="right" valign="top">irr::scene::IMesh *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#ae5717f8fd5450ff34089b4ce89afc444">getMeshCubeFaces</a> (SimpleVoxelEngine::Core::VoxelForRendering *vxlfr, irr::scene::IMesh *plane, irr::core::vector3df planescale)</td></tr>
<tr class="memdesc:ae5717f8fd5450ff34089b4ce89afc444"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получение меша куба с отсечёнными невидимыми гранями.  <a href="#ae5717f8fd5450ff34089b4ce89afc444">Подробнее...</a><br /></td></tr>
<tr class="separator:ae5717f8fd5450ff34089b4ce89afc444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fd258eeafc3a1cc02061775bf860650"><td class="memItemLeft" align="right" valign="top">irr::scene::IMesh *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#a1fd258eeafc3a1cc02061775bf860650">getMeshCubeFaces</a> (SimpleVoxelEngine::Core::VoxelForRendering *vxlfr, irr::scene::IMesh **planes, irr::core::vector3df planescale)</td></tr>
<tr class="memdesc:a1fd258eeafc3a1cc02061775bf860650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получение меша куба с отсечёнными невидимыми гранями. Грани могут быть разными.  <a href="#a1fd258eeafc3a1cc02061775bf860650">Подробнее...</a><br /></td></tr>
<tr class="separator:a1fd258eeafc3a1cc02061775bf860650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087c42f26ac81474176c7c43394dea3b"><td class="memItemLeft" align="right" valign="top">irr::scene::IMesh *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#a087c42f26ac81474176c7c43394dea3b">getMeshVoxelByGlue</a> (SimpleVoxelEngine::Core::VoxelForRendering *vxlfr, irr::scene::IMesh **glues)</td></tr>
<tr class="memdesc:a087c42f26ac81474176c7c43394dea3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Получение меша вокселя с отсечёнными невидимыми гранями из склейки указанных мешей. Грани являются своими мешами.  <a href="#a087c42f26ac81474176c7c43394dea3b">Подробнее...</a><br /></td></tr>
<tr class="separator:a087c42f26ac81474176c7c43394dea3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Подробное описание</h2>
<div class="textblock"><p>Фабрика для управления Irrlicht-нодами чанков. </p>
<p>Данный класс управляет и контролирует все операции, которые производятся с нодами чанков. </p>

<p>См. определение в файле <a class="el" href="_factory_chunk_mesh_scene_node_8h_source.html">FactoryChunkMeshSceneNode.h</a> строка <a class="el" href="_factory_chunk_mesh_scene_node_8h_source.html#l00024">24</a></p>
</div><h2 class="groupheader">Конструктор(ы)</h2>
<a class="anchor" id="a872272a40d68e1bd37bf9261f91591cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::FactoryChunkMeshSceneNode </td>
          <td>(</td>
          <td class="paramtype">irr::IrrlichtDevice *&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_irr_simple_voxel_engine.html">IrrSimpleVoxelEngine</a> *&#160;</td>
          <td class="paramname"><em>isve</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Конструктор с параметрами. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>Указатель на IrrlichtDevice, используемый для отрисовки. </td></tr>
    <tr><td class="paramname">isve</td><td>Указатель на враппер. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8b46d40a950cd201640c221f17015884"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::FactoryChunkMeshSceneNode </td>
          <td>(</td>
          <td class="paramtype">irr::IrrlichtDevice *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Конструктор с параметрами. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>Указатель на IrrlichtDevice, используемый для отрисовки. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Методы</h2>
<a class="anchor" id="a6d334f499012d0578745045992e42818"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::addChunk </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimpleVoxelEngine::Additional::Vector3d&lt; int &gt;&#160;</td>
          <td class="paramname"><em>vect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimpleVoxelEngine::Voxels::ChunkVoxelObject *&#160;</td>
          <td class="paramname"><em>cvo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Низкоуровневая функция добавления чанка. </p>
<p>Данная функция производит все операции для расчёта всех параметров чанка, которые необходимы для отрисовки. Вызывается <a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_irr_simple_voxel_engine.html" title="Движок. ">IrrSimpleVoxelEngine</a> в другом потоке. Не рекомендуется её использовать. </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Идентификатор мира, в котором создаём чанк. </td></tr>
    <tr><td class="paramname">vect</td><td>Вектор (координаты) создаваемого чанка. </td></tr>
    <tr><td class="paramname">cvo</td><td>Указатель на чанк в памяти. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает true в случае успеха, иначе false. </dd></dl>

</div>
</div>
<a class="anchor" id="a6b6a821b0af08b24033e1d37127f075d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Полная очистка фабрики. </p>
<p>Выполняется полная очистка фабрики и освобождение памяти. Разморозка не происходит. Для дальнейшей работы необходимо вызвать функцию <a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#a6502e3f66ddf9e29f0fb34cd3436294f" title="Установка количества мешей одному чанку. ">setNumberOfMeshesSceneNodeForChunk()</a>. </p>

</div>
</div>
<a class="anchor" id="a2f106aa604c5cee5dfb7aa64ff796787"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::deleteAllChunks </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Удаление всех чанков из указанного мира. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Идентификатор мира, из которого удаляются чанки. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1e8184b6b6f6a75e0b5716e3980a3c52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::deleteAllChunks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Удаляение всех чанков. </p>
<p>Удаляет все чанки из всех миров. </p>

</div>
</div>
<a class="anchor" id="a8c39f400eb370453b7dc7b8d20a411ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::deleteChunk </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimpleVoxelEngine::Additional::Vector3d&lt; int &gt;&#160;</td>
          <td class="paramname"><em>vect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Удаление указанного чанка. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Идентификатор мира, из которого удаляется чанк. </td></tr>
    <tr><td class="paramname">vect</td><td>Вектор (координаты) удаляемого чанка. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает true в случае успеха, иначе false. </dd></dl>

</div>
</div>
<a class="anchor" id="a4d4a160995951cb37c9e13e6a55d2173"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::freeze </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Заморозка фабрики. </p>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает true, если фабрика была до вызова этой функции не заморожена, иначе false. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b4d6d07ee7273837f198cd0776395c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">irr::IrrlichtDevice* SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::getIrrlichtDevice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Получение указателя на IrrlichtDevice, используемый для отрисовки. </p>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает указатель на используемый IrrlichtDevice. </dd></dl>

</div>
</div>
<a class="anchor" id="a6f63e6aea079a265afed4bb57b091a89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_irr_simple_voxel_engine.html">IrrSimpleVoxelEngine</a>* SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::getIrrSimpleVoxelEngine </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Получение указателя на используемый враппер. </p>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает указатель на враппер, в котором зарегистрирована данная фабрика. </dd></dl>

</div>
</div>
<a class="anchor" id="ae5717f8fd5450ff34089b4ce89afc444"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">irr::scene::IMesh* SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::getMeshCubeFaces </td>
          <td>(</td>
          <td class="paramtype">SimpleVoxelEngine::Core::VoxelForRendering *&#160;</td>
          <td class="paramname"><em>vxlfr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::scene::IMesh *&#160;</td>
          <td class="paramname"><em>plane</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::core::vector3df&#160;</td>
          <td class="paramname"><em>planescale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получение меша куба с отсечёнными невидимыми гранями. </p>
<p>Данная функция всем граням даёт одинаковый меш, т.е. текстуру, текстурные координаты и все остальные параметры. </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">vxlfr</td><td>Указатель на информацию для отрисовки данного вокселя. В нём так же содержится информация о видимости граней. </td></tr>
    <tr><td class="paramname">plane</td><td>Указатель на меш грани. Это должен быть квадрат со стороной "1", в центре которого находится начало координат. Сам квадрат лежит в плоскости Oxy. Необходимо перед вызовом данной функции произвести все необходимые операции по установке параметров для данного меша. </td></tr>
    <tr><td class="paramname">planescale</td><td>Масштабирование грани. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает указатель на меш вокселя-кубика с учётом невидимых граней. </dd></dl>

</div>
</div>
<a class="anchor" id="a1fd258eeafc3a1cc02061775bf860650"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">irr::scene::IMesh* SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::getMeshCubeFaces </td>
          <td>(</td>
          <td class="paramtype">SimpleVoxelEngine::Core::VoxelForRendering *&#160;</td>
          <td class="paramname"><em>vxlfr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::scene::IMesh **&#160;</td>
          <td class="paramname"><em>planes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::core::vector3df&#160;</td>
          <td class="paramname"><em>planescale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получение меша куба с отсечёнными невидимыми гранями. Грани могут быть разными. </p>
<p>Данная функция даёт возможность дать кубу-вокселю все разные грани. </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">vxlfr</td><td>Указатель на информацию для отрисовки данного вокселя. В нём так же содержится информация о видимости граней. </td></tr>
    <tr><td class="paramname">planes</td><td>Массив указателей на меши граней. Каждый меш должен быть квадратом со стороной "1", в центре которого находится начало координат. Сам квадрат лежит в плоскости Oxy. Необходимо перед вызовом данной функции произвести все необходимые операции по установке параметров для каждого меша грани. Порядок установки граней совпадает с порядком граней в массиве видимости (см. документацию <a class="el" href="namespace_simple_voxel_engine.html" title="Пространство имён SimpleVoxelEngine. ">SimpleVoxelEngine</a>). </td></tr>
    <tr><td class="paramname">planescale</td><td>Масштабирование граней. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает указатель на меш вокселя-кубика с учётом невидимых граней. </dd></dl>

</div>
</div>
<a class="anchor" id="a4217d3d1c4782246cfa52e923a7651be"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::getMeshNumber </td>
          <td>(</td>
          <td class="paramtype">SimpleVoxelEngine::Core::VoxelForRendering *&#160;</td>
          <td class="paramname"><em>vxlfr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получение информации о номере уровня меша, куда будет вклеиваться воксель. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">vxlfr</td><td>Указатель на информацию для отрисовки данного вокселя. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает номер уровня мешей, куда будет вклеен данный воксель. </dd></dl>

</div>
</div>
<a class="anchor" id="a27a2334f771987a227e66ccced46ccc2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual irr::scene::IMesh* SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::getMeshVoxel </td>
          <td>(</td>
          <td class="paramtype">SimpleVoxelEngine::Core::VoxelForRendering *&#160;</td>
          <td class="paramname"><em>vxlfr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получение меша вокселя. </p>
<p>Пользовательская функция. Вызывается для получения меша вокселя, который будет "вклеен" в чанк. </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">vxlfr</td><td>Указатель на информацию для отрисовки данного вокселя. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает указатель на меш данного вокселя, вклеиваемый в чанк. </dd></dl>

</div>
</div>
<a class="anchor" id="a087c42f26ac81474176c7c43394dea3b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">irr::scene::IMesh* SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::getMeshVoxelByGlue </td>
          <td>(</td>
          <td class="paramtype">SimpleVoxelEngine::Core::VoxelForRendering *&#160;</td>
          <td class="paramname"><em>vxlfr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::scene::IMesh **&#160;</td>
          <td class="paramname"><em>glues</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Получение меша вокселя с отсечёнными невидимыми гранями из склейки указанных мешей. Грани являются своими мешами. </p>
<p>Данная функция даёт возможность склеивать воксель из любых мешей с учётом невидимых граней. </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">vxlfr</td><td>Указатель на информацию для отрисовки данного вокселя. В нём так же содержится информация о видимости граней. </td></tr>
    <tr><td class="paramname">glues</td><td>Массив указателей на меши сторон вокселя. Каждый меш должен быть готовой гранью для склейки. Приклеивается "как есть". Необходимо перед вызовом данной функции произвести все необходимые операции по установке параметров для каждого меша грани. Порядок установки мешей граней совпадает с порядком граней в массиве видимости (см. документацию <a class="el" href="namespace_simple_voxel_engine.html" title="Пространство имён SimpleVoxelEngine. ">SimpleVoxelEngine</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает указатель на меш вокселя с учётом невидимых граней. </dd></dl>

</div>
</div>
<a class="anchor" id="a51b5b65a39388449a96dbd6f820b8456"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::getNumberOfMeshesSceneNodeForChunk </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Получение числа мешей у одного чанка. </p>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает число мешей у одного чанка. </dd></dl>

</div>
</div>
<a class="anchor" id="a04386415b4c6a0190972668fe56e3441"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::getOcclusionQueries </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Получение состояния Occlusion Queries. </p>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает значение true, если Occlusion Queries включен, иначе false. </dd></dl>

</div>
</div>
<a class="anchor" id="a82e8a49110d031739b6882018ba186f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::getPositionScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Получение масштаба позиции. </p>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает масштаб позиции. </dd></dl>

</div>
</div>
<a class="anchor" id="ad8e0cc1a4ca98454a4e55228b51bffce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::getRotationScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Получение масштаба поворота. </p>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает масштаб поворота. </dd></dl>

</div>
</div>
<a class="anchor" id="ab090150e96dc7024356301b9b4598787"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::getSScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Получение масштаба масштабирования. </p>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает масштаб масштабирования. </dd></dl>

</div>
</div>
<a class="anchor" id="a1c739f5e8224b2f09571db04113f3f70"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::getTimerTestOcclusionQueriesInMilliseconds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Получение значения таймера Occlusion Queries. </p>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает число, равное значению миллисекунд, раз в которое происходит пересчёт Occlusion Queries. </dd></dl>

</div>
</div>
<a class="anchor" id="abdeaa66b13e2753b3129ffa0da6affe9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::isFaces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Получение состояния получения информации о видимых гранях. </p>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает true, если информация получается, иначе false. </dd></dl>

</div>
</div>
<a class="anchor" id="af25d330bae3295152c0e25b9f32f8885"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::isForUpdateChunk </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimpleVoxelEngine::Additional::Vector3d&lt; int &gt;&#160;</td>
          <td class="paramname"><em>vect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Проверка состояния пометки для обновления. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Идентификатор мира, в котором проверяем состояние пометки чанка. </td></tr>
    <tr><td class="paramname">vect</td><td>Вектор (координаты) проверямого чанка. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает true, если чанк помечен для обновления, иначе false. </dd></dl>

</div>
</div>
<a class="anchor" id="a1cf68b66c7425b4d56322089f5f1fe17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::isFreeze </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Проверка состояния заморозки фабрики. </p>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает true, если фабрика заморожена, иначе false. </dd></dl>

</div>
</div>
<a class="anchor" id="a6c37ea4edd78bb64a691cc00b9a09402"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::isMultiplePartition </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Проверка на тип разбиения. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Идентификатор мира, где проверяется тип разбиения. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает true, если разбиение всех чанков на всех уровнях одинаково, иначе false. </dd></dl>

</div>
</div>
<a class="anchor" id="ac9a5f7189898833b1184a43854a0a5ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::isRenderChunk </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimpleVoxelEngine::Additional::Vector3d&lt; int &gt;&#160;</td>
          <td class="paramname"><em>vect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Проверка состояния отрисовки чанка. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Идентификатор мира, в котором проверяем состояние чанка. </td></tr>
    <tr><td class="paramname">vect</td><td>Вектор (координаты) проверямого чанка. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает true, если чанк отрисовывается, иначе false. </dd></dl>

</div>
</div>
<a class="anchor" id="ab691e406ad430ecdbca14bbb1934ffec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::onUpdateChunkMeshSceneNode </td>
          <td>(</td>
          <td class="paramtype">irr::scene::IMeshSceneNode *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numbermesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimpleVoxelEngine::Additional::Vector3d&lt; int &gt;&#160;</td>
          <td class="paramname"><em>vectblock</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Окончательная обработка при обновлении Irrlicht-ноды чанка. </p>
<p>Пользовательская функция. Вызывается после создания Irrlicht-ноды чанка. </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>Указатель на Irrlicht-ноду чанка. </td></tr>
    <tr><td class="paramname">numbermesh</td><td>Номер уровня меша. </td></tr>
    <tr><td class="paramname">vectblock</td><td>Вектор (координаты) ноды в относительных координатах блока чанков. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acda0d00b58fae7bc387bd6c1402ba2a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::setChunkForUpdate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimpleVoxelEngine::Additional::Vector3d&lt; int &gt;&#160;</td>
          <td class="paramname"><em>vect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Пометить чанк для обновления. </p>
<p>Помечает указанный чанк для обновления. </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Идентификатор мира, в котором чанк помечается для обновления. </td></tr>
    <tr><td class="paramname">vect</td><td>Вектор (координаты) помечаемого чанка. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a768bbf1d6e6599220c98e05fa998efd9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::setHardwareMappingHint </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numbermesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::scene::E_HARDWARE_MAPPING&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::scene::E_BUFFER_TYPE&#160;</td>
          <td class="paramname"><em>buffertype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Установка hardware mapping hint для всех чанков на указанном уровне по умолчанию. </p>
<p>Эту функцию необходимо вызывать до начала создания миров. </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">numbermesh</td><td>Номер меша, которому устанавливаем значения. </td></tr>
    <tr><td class="paramname">mapping</td><td>Тип mapping из Irrlicht. </td></tr>
    <tr><td class="paramname">buffertype</td><td>Тип буффера из Irrlicht. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3ccd73bfa1c8b3d232d3105470d56bd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::setHardwareMappingHint </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numbermesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::scene::E_HARDWARE_MAPPING&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::scene::E_BUFFER_TYPE&#160;</td>
          <td class="paramname"><em>buffertype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Установка hardware mapping hint для всех чанков на указанном уровне данному миру. </p>
<p>Эту функцию необходимо вызывать после создания мира. Перекрывает значения по умолчанию. </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">numbermesh</td><td>Номер меша, которому устанавливаем значения. </td></tr>
    <tr><td class="paramname">id</td><td>Идентификатор мира, в котором устанавливаются значения. </td></tr>
    <tr><td class="paramname">mapping</td><td>Тип mapping из Irrlicht. </td></tr>
    <tr><td class="paramname">buffertype</td><td>Тип буффера из Irrlicht. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a71953494b410b0581669891fda1e5002"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::setID </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numbermesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::s32&#160;</td>
          <td class="paramname"><em>idscenenode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Установка ID чанков в указанном мире на указанном уровне. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">numbermesh</td><td>Номер уровня, для мешей которого происходит установка ID. </td></tr>
    <tr><td class="paramname">id</td><td>Идентификатор мира, в котором происходит установка значения ID. </td></tr>
    <tr><td class="paramname">idscenenode</td><td>Устанавливаемый ID нодам чанков. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a867afc5632aa9557c20778b694051882"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::setIrrlichtDevice </td>
          <td>(</td>
          <td class="paramtype">irr::IrrlichtDevice *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Установка IrrlichtDevice для отрисовки. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>Указатель на устанавливаемый IrrlichtDevice. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает true в случае успеха, иначе false. </dd></dl>

</div>
</div>
<a class="anchor" id="af01547050ddd128ad7ac64f5384d84fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::setIrrSimpleVoxelEngine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_irr_simple_voxel_engine.html">IrrSimpleVoxelEngine</a> *&#160;</td>
          <td class="paramname"><em>isve</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Установка используемого враппера. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">isve</td><td>Указатель на устанавливаемый враппер. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает true в случае успеха, иначе false. </dd></dl>

</div>
</div>
<a class="anchor" id="a8bf2e165d34e4916e4c813332b5e9466"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::setIsFaces </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Установка получения при отрисовке чанков информации о видимых гранях. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Если имеет значение true, то информация будет получаться, иначе нет. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает true в случае успеха, иначе false. </dd></dl>

</div>
</div>
<a class="anchor" id="a9de19a98a848a6e573157353d5d6d0ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::setMaterialFlag </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numbermesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::video::E_MATERIAL_FLAG&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Установка флага материала. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">numbermesh</td><td>Номер уровня меша, для чанково которых идёт установка флага материала. </td></tr>
    <tr><td class="paramname">id</td><td>Идентификатор мира, чанкам которых устанавливаем флаг. </td></tr>
    <tr><td class="paramname">flag</td><td>Irrlicht флаг. </td></tr>
    <tr><td class="paramname">value</td><td>Значение флага. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9177a4a69c056fd5273f80ff5fc28c71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::setMaterialType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numbermesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::video::E_MATERIAL_TYPE&#160;</td>
          <td class="paramname"><em>newtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Установка типа материала на указанном уровне для всех чанков на указанном уровне по умолчанию. </p>
<p>Эту функцию необходимо вызывать до начала создания миров. </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">numbermesh</td><td>Номер уровня, для мешей которого происходит изменение типа материала. </td></tr>
    <tr><td class="paramname">newtype</td><td>Новый Irrlicht материал. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afbc5184569b3b8685808d11747e281f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::setMaterialType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numbermesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::video::E_MATERIAL_TYPE&#160;</td>
          <td class="paramname"><em>newtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Установка типа материала на указанном уровне для всех чанков на указанном уровне данному миру. </p>
<p>Эту функцию необходимо вызывать после создания мира. Перекрывает значения по умолчанию. </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">numbermesh</td><td>Номер уровня, для мешей которого происходит изменение типа материала. </td></tr>
    <tr><td class="paramname">id</td><td>Идентификатор мира, в котором устанавливаются значения. </td></tr>
    <tr><td class="paramname">newtype</td><td>Новый Irrlicht материал. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a39838272d8e9c3183eb50ad447a24b16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::setMultiplePartition </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>mp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Установка типа разбиения чанков. </p>
<p>Если имеет значение true, то все чанки имеют одинаковые размеры разбиения на всех уровнях. В этом случае проще поиск вокселей, а так же при рендеринге больше граней отсекаются. </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Идентификатор мира, для которого происходит установка значения. </td></tr>
    <tr><td class="paramname">mp</td><td>Значение. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a6502e3f66ddf9e29f0fb34cd3436294f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::setNumberOfMeshesSceneNodeForChunk </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nomsnfc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Установка количества мешей одному чанку. </p>
<p>Разные меши могут иметь разные материалы, ID и так далее. К примеру, можно сделать нулевой меш - твёрдые материалы, 1-й - стекло и так далее. </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">nomsnfc</td><td>Устанавливаемое количество мешей. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af4fffee34ecf5afae1c7624d6877eb6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::setOcclusionQueries </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Установка Occlusion Queries. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Если имеет значение true, то Occlusion Queries будет включен, иначе выключен. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4ecbc0d9fe64b98eae06cae52c030554"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::setPositionScale </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ps</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Установка масштаба позиции. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">ps</td><td>Устанавливаемый масштаб позиции. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает true в случае успеха, иначе false. </dd></dl>

</div>
</div>
<a class="anchor" id="a76b0e22b06a466dbcb725cf88f42dcef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::setRotationScale </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>rs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Установка масштаба поворота. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">rs</td><td>Устанавливаемый масштаб поворота. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает true в случае успеха, иначе false. </dd></dl>

</div>
</div>
<a class="anchor" id="a5d0bb1e5704dae48325e3cfb7d602b5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::setSizeBlockChunks </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ysize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Установка кубоида для объединения чанков в один меш. </p>
<p>Устанавливает размер всех кубов из чанков, который объединяется в один меш. Эту функцию необходимо вызывать после создания мира. Перекрывает значения по умолчанию. </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Идентификатор мира, для которого устанавливаются значения. </td></tr>
    <tr><td class="paramname">xsize</td><td>Размер куба из чанков по X. </td></tr>
    <tr><td class="paramname">ysize</td><td>Размер куба из чанков по Y. </td></tr>
    <tr><td class="paramname">zsize</td><td>Размер куба из чанков по Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1607b8c31f317c7501261dfd7c2db4d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::setSizeBlockChunks </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ysize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>zsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Установка кубоида для объединения чанков в один меш по умолчанию. </p>
<p>Устанавливает размер всех кубов из чанков, который объединяется в один меш. Эту функцию необходимо вызывать до начала создания миров. </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">xsize</td><td>Размер куба из чанков по X. </td></tr>
    <tr><td class="paramname">ysize</td><td>Размер куба из чанков по Y. </td></tr>
    <tr><td class="paramname">zsize</td><td>Размер куба из чанков по Z. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac28982234390cbf99bbd1bea12e508b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::setSScale </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>ss</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Установка масштаба масштабирования. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">ss</td><td>Устанавливаемый масштаб масштабирования. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает true в случае успеха, иначе false. </dd></dl>

</div>
</div>
<a class="anchor" id="a913a15c86b99563055ec0c320ceff423"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::setTimerTestOcclusionQueriesInMilliseconds </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>timer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Установка таймера пересчёта Occlusion Queries. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">timer</td><td>Устанавливаемое значение миллисекунд, раз в которое происходит пересчёт Occlusion Queries. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac1a7b3250fc857a8991d06ec5ece727f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::update </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Главная функция, отвечающая за работу фабрики. </p>
<p>При вызове данной функции происходит обработка всех задач, находящихся в очереди. </p>

</div>
</div>
<a class="anchor" id="a3edc521898539f4e696a14020960e448"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::updateAllChunks </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Создание задания на обновление всех чанков из заданного мира. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Идентификатор мира, чанки которого необходимо обновить. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a69580519b23ed6e3513e1be30199330d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::updateAllChunks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Создание задания на обновление всех чанков из всех зарегистрированных миров. </p>
<p>Отправляет в очередь задание на обновление всех чанков. </p>

</div>
</div>
<a class="anchor" id="aa734bf6f354a56fdcfa07178d99dc610"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::updateCameraPosition </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">irr::core::vector3df&#160;</td>
          <td class="paramname"><em>vect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Обновление позиции камеры. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Идентификатор мира, в котором обновляется позиция камеры. </td></tr>
    <tr><td class="paramname">vect</td><td>Новая позиция камеры. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a10d85216b79da409438ce49eb738e38e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::updateChunk </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimpleVoxelEngine::Additional::Vector3d&lt; int &gt;&#160;</td>
          <td class="paramname"><em>vect</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>saveplace</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Создание задания на обновление указанного чанка. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Идентификатор мира, из которого обновляемый чанк. </td></tr>
    <tr><td class="paramname">vect</td><td>Вектор (координаты) обновляемого чанка. </td></tr>
    <tr><td class="paramname">saveplace</td><td>Сохранять ли место в контейнере под чанк. Параметр специфический и только для внутренней работы движка. Использовать не рекомендуется. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Возвращает true, если задание создано успешно, иначе false. </dd></dl>

</div>
</div>
<a class="anchor" id="abbc7b7dbbecb9bf3c694ba825c865e0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::updateChunks </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Создание задания на обновление чанков из помеченных на обновление из заданного мира. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Идентификатор мира, чанки которого необходимо обновить. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a09f0f4b1d2c348614da81cc8abeeb9bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::updateChunks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Создание задания на обновление чанков из помеченных на обновление из всех зарегистрированных миров. </p>
<p>Отправляет в очередь задание на обновление помеченных на обновление чанков. </p>

</div>
</div>
<a class="anchor" id="a0e691b2568ddf7d0b70ee3c03252832d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::updateMeshChunk </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numbermesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimpleVoxelEngine::Additional::Vector3d&lt; int &gt;&#160;</td>
          <td class="paramname"><em>vect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Обновление меша заданного чанка в заданном мире только на заданном уровне. </p>
<p>Окончательная обработка меша чанка в заданном мире только на заданном уровне. </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">numbermesh</td><td>Номер уровня мешей, на котором идёт обработка. </td></tr>
    <tr><td class="paramname">id</td><td>Идентификатор мира, в котором находится обрабатываемый чанк. </td></tr>
    <tr><td class="paramname">vect</td><td>Вектор (координаты) обрабатываемого чанка. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa95296d1a3a9cea643ec22ca83c9d7b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::updateMeshChunk </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimpleVoxelEngine::Additional::Vector3d&lt; int &gt;&#160;</td>
          <td class="paramname"><em>vect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Обновление меша заданного чанка в заданном мире. </p>
<p>Окончательная обработка меша чанка в заданном мире. </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Идентификатор мира, в котором находится обрабатываемый чанк. </td></tr>
    <tr><td class="paramname">vect</td><td>Вектор (координаты) обрабатываемого чанка. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2e022418d14e9f06d2dfe33173bb81c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::updateMeshChunks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Обновление мешей чанков. </p>
<p>Окончательная обработка мешей чанков из очереди. </p>

</div>
</div>
<a class="anchor" id="a59f11bfe48793212e75b088203e9ac2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::updateMeshChunks </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numbermesh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Обновление мешей чанков только на заданном уровне. </p>
<p>Окончательная обработка мешей чанков на заданном уровне из очереди. </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">numbermesh</td><td>Номер уровня мешей, на котором идёт обработка. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3841b85da31be2ff7eb6113cece5b626"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::updateMeshChunks </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numbermesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Обновление мешей чанков в заданном мире только на заданном уровне. </p>
<p>Окончательная обработка мешей чанков в заданном мире на заданном уровне. Дублируется <a class="el" href="class_simple_voxel_engine_1_1_irr_engine_1_1_factory_chunk_mesh_scene_node.html#a0e691b2568ddf7d0b70ee3c03252832d" title="Обновление меша заданного чанка в заданном мире только на заданном уровне. ">updateMeshChunk()</a>. </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">numbermesh</td><td>Номер уровня мешей, на котором идёт обработка. </td></tr>
    <tr><td class="paramname">id</td><td>Идентификатор мира, для которого происходит обработка. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a97bacb0a9a0c4331ecf199b7101d1854"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::updateMeshChunksByWorldId </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Обновление мешей чанков в заданном мире. </p>
<p>Окончательная обработка мешей чанков в заданном мире. </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Идентификатор мира, для которого происходит обработка. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0b3dbb84aa7bf1b095002698d103c69d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SimpleVoxelEngine::IrrEngine::FactoryChunkMeshSceneNode::updateMeshChunksByWorldIdAndVector </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SimpleVoxelEngine::Additional::Vector3d&lt; int &gt;&#160;</td>
          <td class="paramname"><em>vect</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Обновление меша заданного чанка в заданном мире. </p>
<p>Окончательная обработка меша чанка в заданном мире. </p><dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">id</td><td>Идентификатор мира, в котором находится обрабатываемый чанк. </td></tr>
    <tr><td class="paramname">vect</td><td>Вектор (координаты) обрабатываемого чанка. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>Объявления и описания членов класса находятся в файле:<ul>
<li><a class="el" href="_factory_chunk_mesh_scene_node_8h_source.html">FactoryChunkMeshSceneNode.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Документация по IrrSimpleVoxelEngine. Последние изменения: Чт 17 Сен 2015 12:55:37. Создано системой &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
