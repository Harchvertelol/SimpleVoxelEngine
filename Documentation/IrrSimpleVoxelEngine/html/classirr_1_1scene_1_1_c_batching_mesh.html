<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>IrrSimpleVoxelEngine: Класс irr::scene::CBatchingMesh</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">IrrSimpleVoxelEngine
   &#160;<span id="projectnumber">build 0.0.1</span>
   </div>
   <div id="projectbrief">Враппер для воксельного движка на irrlicht</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Создано системой Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Поиск');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Титульная&#160;страница</span></a></li>
      <li><a href="pages.html"><span>Описания</span></a></li>
      <li><a href="namespaces.html"><span>Пространства&#160;имен</span></a></li>
      <li class="current"><a href="annotated.html"><span>Классы</span></a></li>
      <li><a href="files.html"><span>Файлы</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Поиск" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Классы</span></a></li>
      <li><a href="classes.html"><span>Алфавитный&#160;указатель&#160;классов</span></a></li>
      <li><a href="hierarchy.html"><span>Иерархия&#160;классов</span></a></li>
      <li><a href="functions.html"><span>Члены&#160;классов</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>Указатель</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Классы</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Пространства имен</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Файлы</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Функции</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Переменные</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Перечисления</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Элементы перечислений</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Друзья</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Страницы</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>irr</b></li><li class="navelem"><b>scene</b></li><li class="navelem"><a class="el" href="classirr_1_1scene_1_1_c_batching_mesh.html">CBatchingMesh</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Классы</a> &#124;
<a href="#pub-methods">Открытые члены</a> &#124;
<a href="classirr_1_1scene_1_1_c_batching_mesh-members.html">Полный список членов класса</a>  </div>
  <div class="headertitle">
<div class="title">Класс irr::scene::CBatchingMesh</div>  </div>
</div><!--header-->
<div class="contents">

<p>Class for batching meshes.  
 <a href="classirr_1_1scene_1_1_c_batching_mesh.html#details">Подробнее...</a></p>

<p><code>#include &lt;<a class="el" href="_c_batching_mesh_8h_source.html">CBatchingMesh.h</a>&gt;</code></p>
<div class="dynheader">
Граф наследования:irr::scene::CBatchingMesh:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classirr_1_1scene_1_1_c_batching_mesh.png" usemap="#irr::scene::CBatchingMesh_map" alt=""/>
  <map id="irr::scene::CBatchingMesh_map" name="irr::scene::CBatchingMesh_map">
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Открытые члены</h2></td></tr>
<tr class="memitem:af11c3b5167830229a88ee0d935dc734e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af11c3b5167830229a88ee0d935dc734e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_batching_mesh.html#af11c3b5167830229a88ee0d935dc734e">CBatchingMesh</a> ()</td></tr>
<tr class="memdesc:af11c3b5167830229a88ee0d935dc734e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standart constructor. <br /></td></tr>
<tr class="separator:af11c3b5167830229a88ee0d935dc734e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed32c2b8932e5060c70b49285e9d0c08"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed32c2b8932e5060c70b49285e9d0c08"></a>
virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_batching_mesh.html#aed32c2b8932e5060c70b49285e9d0c08">~CBatchingMesh</a> ()</td></tr>
<tr class="memdesc:aed32c2b8932e5060c70b49285e9d0c08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standart destructor. <br /></td></tr>
<tr class="separator:aed32c2b8932e5060c70b49285e9d0c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab07f538e2cde8fecc2de1d47bb684dee"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab07f538e2cde8fecc2de1d47bb684dee"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_batching_mesh.html#ab07f538e2cde8fecc2de1d47bb684dee">isDirty</a> (s32 id=-1)</td></tr>
<tr class="memdesc:ab07f538e2cde8fecc2de1d47bb684dee"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if new buffers have been added without updating the internal buffers <br /></td></tr>
<tr class="separator:ab07f538e2cde8fecc2de1d47bb684dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8090af4c123d35b03654d80981a31e0b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8090af4c123d35b03654d80981a31e0b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_batching_mesh.html#a8090af4c123d35b03654d80981a31e0b">update</a> ()</td></tr>
<tr class="memdesc:a8090af4c123d35b03654d80981a31e0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">refreshes the internal buffers from source <br /></td></tr>
<tr class="separator:a8090af4c123d35b03654d80981a31e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27f15a9680eeb08bd867827d32d98b0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae27f15a9680eeb08bd867827d32d98b0"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_batching_mesh.html#ae27f15a9680eeb08bd867827d32d98b0">clear</a> ()</td></tr>
<tr class="memdesc:ae27f15a9680eeb08bd867827d32d98b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">drops all buffers and clears internal states <br /></td></tr>
<tr class="separator:ae27f15a9680eeb08bd867827d32d98b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0867957d15cba2e4d02bbbb3b58ba4d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_batching_mesh.html#a0867957d15cba2e4d02bbbb3b58ba4d9">finalize</a> ()</td></tr>
<tr class="memdesc:a0867957d15cba2e4d02bbbb3b58ba4d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">first updates the mesh, then drops all source buffers.  <a href="#a0867957d15cba2e4d02bbbb3b58ba4d9">Подробнее...</a><br /></td></tr>
<tr class="separator:a0867957d15cba2e4d02bbbb3b58ba4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc3aa1f5c90f27aa47e7082c7d56019"><td class="memItemLeft" align="right" valign="top">core::array&lt; s32 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_batching_mesh.html#a4cc3aa1f5c90f27aa47e7082c7d56019">addMesh</a> (IMesh *mesh, core::vector3df pos=core::vector3df(0, 0, 0), core::vector3df rot=core::vector3df(0, 0, 0), core::vector3df scale=core::vector3df(1, 1, 1))</td></tr>
<tr class="memdesc:a4cc3aa1f5c90f27aa47e7082c7d56019"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a mesh to the buffers with the given offset  <a href="#a4cc3aa1f5c90f27aa47e7082c7d56019">Подробнее...</a><br /></td></tr>
<tr class="separator:a4cc3aa1f5c90f27aa47e7082c7d56019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b932df511114a945a2c3aa01f0edc6"><td class="memItemLeft" align="right" valign="top">core::array&lt; s32 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_batching_mesh.html#a31b932df511114a945a2c3aa01f0edc6">addMesh</a> (IMesh *mesh, const core::matrix4 &amp;transform)</td></tr>
<tr class="memdesc:a31b932df511114a945a2c3aa01f0edc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a mesh with the given transformation  <a href="#a31b932df511114a945a2c3aa01f0edc6">Подробнее...</a><br /></td></tr>
<tr class="separator:a31b932df511114a945a2c3aa01f0edc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c3db93f3b3b1c28a99975cc21ed382c"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_batching_mesh.html#a5c3db93f3b3b1c28a99975cc21ed382c">addMeshBuffer</a> (IMeshBuffer *buffer, core::vector3df pos=core::vector3df(0, 0, 0), core::vector3df rot=core::vector3df(0, 0, 0), core::vector3df scale=core::vector3df(1, 1, 1))</td></tr>
<tr class="memdesc:a5c3db93f3b3b1c28a99975cc21ed382c"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a mesh buffer with the given transformation  <a href="#a5c3db93f3b3b1c28a99975cc21ed382c">Подробнее...</a><br /></td></tr>
<tr class="separator:a5c3db93f3b3b1c28a99975cc21ed382c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9e2561bac6306325e4aa58d75faf0b9"><td class="memItemLeft" align="right" valign="top">s32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_batching_mesh.html#af9e2561bac6306325e4aa58d75faf0b9">addMeshBuffer</a> (IMeshBuffer *buffer, const core::matrix4 &amp;transform)</td></tr>
<tr class="memdesc:af9e2561bac6306325e4aa58d75faf0b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">adds a mesh with the given transformation  <a href="#af9e2561bac6306325e4aa58d75faf0b9">Подробнее...</a><br /></td></tr>
<tr class="separator:af9e2561bac6306325e4aa58d75faf0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff1cf056c05adeb0cadbd071f44220c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0ff1cf056c05adeb0cadbd071f44220c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_batching_mesh.html#a0ff1cf056c05adeb0cadbd071f44220c">recalculateBoundingBox</a> ()</td></tr>
<tr class="memdesc:a0ff1cf056c05adeb0cadbd071f44220c"><td class="mdescLeft">&#160;</td><td class="mdescRight">updates bouding box from internal buffers <br /></td></tr>
<tr class="separator:a0ff1cf056c05adeb0cadbd071f44220c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc7f5225368f2a4bbb8731d4a64ed64"><td class="memItemLeft" align="right" valign="top">core::array&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_batching_mesh.html#a7fc7f5225368f2a4bbb8731d4a64ed64">moveMesh</a> (const core::array&lt; s32 &gt; &amp;bufferIDs, const core::matrix4 &amp;newMatrix)</td></tr>
<tr class="memdesc:a7fc7f5225368f2a4bbb8731d4a64ed64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves a mesh,.  <a href="#a7fc7f5225368f2a4bbb8731d4a64ed64">Подробнее...</a><br /></td></tr>
<tr class="separator:a7fc7f5225368f2a4bbb8731d4a64ed64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a468a4ebaf0ec5f53f36f438579855775"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_batching_mesh.html#a468a4ebaf0ec5f53f36f438579855775">moveMeshBuffer</a> (const s32 id, const core::matrix4 &amp;newMatrix)</td></tr>
<tr class="memdesc:a468a4ebaf0ec5f53f36f438579855775"><td class="mdescLeft">&#160;</td><td class="mdescRight">Moves a mesh buffer.  <a href="#a468a4ebaf0ec5f53f36f438579855775">Подробнее...</a><br /></td></tr>
<tr class="separator:a468a4ebaf0ec5f53f36f438579855775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8b9aaf9df2f1e9934dd1f9c2ead3b3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace8b9aaf9df2f1e9934dd1f9c2ead3b3"></a>
IMeshBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_batching_mesh.html#ace8b9aaf9df2f1e9934dd1f9c2ead3b3">getSourceBuffer</a> (s32 id)</td></tr>
<tr class="memdesc:ace8b9aaf9df2f1e9934dd1f9c2ead3b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the source buffer, if available <br /></td></tr>
<tr class="separator:ace8b9aaf9df2f1e9934dd1f9c2ead3b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f607145d3cdc38b50376f70371e662f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9f607145d3cdc38b50376f70371e662f"></a>
core::matrix4&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_batching_mesh.html#a9f607145d3cdc38b50376f70371e662f">getSourceBufferMatrix</a> (s32 id)</td></tr>
<tr class="memdesc:a9f607145d3cdc38b50376f70371e662f"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the matrix of the source buffer <br /></td></tr>
<tr class="separator:a9f607145d3cdc38b50376f70371e662f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0205cf23ce7428942444bae0a9787591"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0205cf23ce7428942444bae0a9787591"></a>
u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_batching_mesh.html#a0205cf23ce7428942444bae0a9787591">getSourceBufferCount</a> () const </td></tr>
<tr class="memdesc:a0205cf23ce7428942444bae0a9787591"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the number of source buffers <br /></td></tr>
<tr class="separator:a0205cf23ce7428942444bae0a9787591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b3390d5b2f10ce080e094cfd95e605"><td class="memItemLeft" align="right" valign="top">virtual u32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_batching_mesh.html#a48b3390d5b2f10ce080e094cfd95e605">getMeshBufferCount</a> () const </td></tr>
<tr class="memdesc:a48b3390d5b2f10ce080e094cfd95e605"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the amount of mesh buffers.  <a href="#a48b3390d5b2f10ce080e094cfd95e605">Подробнее...</a><br /></td></tr>
<tr class="separator:a48b3390d5b2f10ce080e094cfd95e605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48662afecfa5f378b4ddebd3375377ec"><td class="memItemLeft" align="right" valign="top">virtual IMeshBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_batching_mesh.html#a48662afecfa5f378b4ddebd3375377ec">getMeshBuffer</a> (u32 nr) const </td></tr>
<tr class="memdesc:a48662afecfa5f378b4ddebd3375377ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to a mesh buffer.  <a href="#a48662afecfa5f378b4ddebd3375377ec">Подробнее...</a><br /></td></tr>
<tr class="separator:a48662afecfa5f378b4ddebd3375377ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b4d24a97194bb2e5129c4ee1c587a7"><td class="memItemLeft" align="right" valign="top">virtual IMeshBuffer *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_batching_mesh.html#a46b4d24a97194bb2e5129c4ee1c587a7">getMeshBuffer</a> (const video::SMaterial &amp;material) const </td></tr>
<tr class="memdesc:a46b4d24a97194bb2e5129c4ee1c587a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns pointer to a mesh buffer which fits a material.  <a href="#a46b4d24a97194bb2e5129c4ee1c587a7">Подробнее...</a><br /></td></tr>
<tr class="separator:a46b4d24a97194bb2e5129c4ee1c587a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c88c1aa099366a85b5e986b380c955"><td class="memItemLeft" align="right" valign="top">virtual const core::aabbox3d<br class="typebreak" />
&lt; f32 &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_batching_mesh.html#a37c88c1aa099366a85b5e986b380c955">getBoundingBox</a> () const </td></tr>
<tr class="memdesc:a37c88c1aa099366a85b5e986b380c955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an axis aligned bounding box of the mesh.  <a href="#a37c88c1aa099366a85b5e986b380c955">Подробнее...</a><br /></td></tr>
<tr class="separator:a37c88c1aa099366a85b5e986b380c955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac723d897f5a287a94c65fcd27ceba419"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac723d897f5a287a94c65fcd27ceba419"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_batching_mesh.html#ac723d897f5a287a94c65fcd27ceba419">setBoundingBox</a> (const core::aabbox3df &amp;box)</td></tr>
<tr class="memdesc:ac723d897f5a287a94c65fcd27ceba419"><td class="mdescLeft">&#160;</td><td class="mdescRight">set user axis aligned bounding box <br /></td></tr>
<tr class="separator:ac723d897f5a287a94c65fcd27ceba419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9ede4f4f54878aa2a45333ec125899"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_batching_mesh.html#a1f9ede4f4f54878aa2a45333ec125899">setMaterialFlag</a> (video::E_MATERIAL_FLAG flag, bool newvalue)</td></tr>
<tr class="memdesc:a1f9ede4f4f54878aa2a45333ec125899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a flag of all contained materials to a new value.  <a href="#a1f9ede4f4f54878aa2a45333ec125899">Подробнее...</a><br /></td></tr>
<tr class="separator:a1f9ede4f4f54878aa2a45333ec125899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d6b43900f252cf61453bcd86165c94f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d6b43900f252cf61453bcd86165c94f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_batching_mesh.html#a8d6b43900f252cf61453bcd86165c94f">setHardwareMappingHint</a> (E_HARDWARE_MAPPING mapping, E_BUFFER_TYPE type)</td></tr>
<tr class="memdesc:a8d6b43900f252cf61453bcd86165c94f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set HMH. <br /></td></tr>
<tr class="separator:a8d6b43900f252cf61453bcd86165c94f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6773a576bf9c041c0e190fdd8d6c7d4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad6773a576bf9c041c0e190fdd8d6c7d4"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classirr_1_1scene_1_1_c_batching_mesh.html#ad6773a576bf9c041c0e190fdd8d6c7d4">setDirty</a> (E_BUFFER_TYPE type)</td></tr>
<tr class="memdesc:ad6773a576bf9c041c0e190fdd8d6c7d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set dirty. <br /></td></tr>
<tr class="separator:ad6773a576bf9c041c0e190fdd8d6c7d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Подробное описание</h2>
<div class="textblock"><p>Class for batching meshes. </p>

<p>См. определение в файле <a class="el" href="_c_batching_mesh_8h_source.html">CBatchingMesh.h</a> строка <a class="el" href="_c_batching_mesh_8h_source.html#l00019">19</a></p>
</div><h2 class="groupheader">Методы</h2>
<a class="anchor" id="a4cc3aa1f5c90f27aa47e7082c7d56019"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">core::array&lt;s32&gt; irr::scene::CBatchingMesh::addMesh </td>
          <td>(</td>
          <td class="paramtype">IMesh *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">core::vector3df&#160;</td>
          <td class="paramname"><em>pos</em> = <code>core::vector3df(0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">core::vector3df&#160;</td>
          <td class="paramname"><em>rot</em> = <code>core::vector3df(0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">core::vector3df&#160;</td>
          <td class="paramname"><em>scale</em> = <code>core::vector3df(1,&#160;1,&#160;1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adds a mesh to the buffers with the given offset </p>
<dl class="section return"><dt>Возвращает</dt><dd>: Returns an array of ID numbers </dd></dl>

</div>
</div>
<a class="anchor" id="a31b932df511114a945a2c3aa01f0edc6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">core::array&lt;s32&gt; irr::scene::CBatchingMesh::addMesh </td>
          <td>(</td>
          <td class="paramtype">IMesh *&#160;</td>
          <td class="paramname"><em>mesh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const core::matrix4 &amp;&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adds a mesh with the given transformation </p>
<dl class="section return"><dt>Возвращает</dt><dd>: Returns an array of ID numbers </dd></dl>

</div>
</div>
<a class="anchor" id="a5c3db93f3b3b1c28a99975cc21ed382c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 irr::scene::CBatchingMesh::addMeshBuffer </td>
          <td>(</td>
          <td class="paramtype">IMeshBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">core::vector3df&#160;</td>
          <td class="paramname"><em>pos</em> = <code>core::vector3df(0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">core::vector3df&#160;</td>
          <td class="paramname"><em>rot</em> = <code>core::vector3df(0,&#160;0,&#160;0)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">core::vector3df&#160;</td>
          <td class="paramname"><em>scale</em> = <code>core::vector3df(1,&#160;1,&#160;1)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adds a mesh buffer with the given transformation </p>
<dl class="section return"><dt>Возвращает</dt><dd>: Returns the ID of this mesh buffer </dd></dl>

</div>
</div>
<a class="anchor" id="af9e2561bac6306325e4aa58d75faf0b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">s32 irr::scene::CBatchingMesh::addMeshBuffer </td>
          <td>(</td>
          <td class="paramtype">IMeshBuffer *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const core::matrix4 &amp;&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>adds a mesh with the given transformation </p>
<dl class="section return"><dt>Возвращает</dt><dd>Returns the ID of this mesh buffer </dd></dl>

</div>
</div>
<a class="anchor" id="a0867957d15cba2e4d02bbbb3b58ba4d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void irr::scene::CBatchingMesh::finalize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>first updates the mesh, then drops all source buffers. </p>
<p>once this mesh has been finalized, it cannot be changed again! </p>

</div>
</div>
<a class="anchor" id="a37c88c1aa099366a85b5e986b380c955"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const core::aabbox3d&lt;f32&gt;&amp; irr::scene::CBatchingMesh::getBoundingBox </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an axis aligned bounding box of the mesh. </p>
<dl class="section return"><dt>Возвращает</dt><dd>A bounding box of this mesh is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a48662afecfa5f378b4ddebd3375377ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual IMeshBuffer* irr::scene::CBatchingMesh::getMeshBuffer </td>
          <td>(</td>
          <td class="paramtype">u32&#160;</td>
          <td class="paramname"><em>nr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns pointer to a mesh buffer. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">nr</td><td>Zero based index of the mesh buffer. The maximum value is <a class="el" href="classirr_1_1scene_1_1_c_batching_mesh.html#a48b3390d5b2f10ce080e094cfd95e605" title="Returns the amount of mesh buffers. ">getMeshBufferCount()</a> - 1; </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Returns the pointer to the mesh buffer or NULL if there is no such mesh buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a46b4d24a97194bb2e5129c4ee1c587a7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual IMeshBuffer* irr::scene::CBatchingMesh::getMeshBuffer </td>
          <td>(</td>
          <td class="paramtype">const video::SMaterial &amp;&#160;</td>
          <td class="paramname"><em>material</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns pointer to a mesh buffer which fits a material. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">material</td><td>material to search for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Возвращает</dt><dd>Returns the pointer to the mesh buffer or NULL if there is no such mesh buffer. </dd></dl>

</div>
</div>
<a class="anchor" id="a48b3390d5b2f10ce080e094cfd95e605"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual u32 irr::scene::CBatchingMesh::getMeshBufferCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the amount of mesh buffers. </p>
<dl class="section return"><dt>Возвращает</dt><dd>Returns the amount of mesh buffers (IMeshBuffer) in this mesh. </dd></dl>

</div>
</div>
<a class="anchor" id="a7fc7f5225368f2a4bbb8731d4a64ed64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">core::array&lt;bool&gt; irr::scene::CBatchingMesh::moveMesh </td>
          <td>(</td>
          <td class="paramtype">const core::array&lt; s32 &gt; &amp;&#160;</td>
          <td class="paramname"><em>bufferIDs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const core::matrix4 &amp;&#160;</td>
          <td class="paramname"><em>newMatrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves a mesh,. </p>
<p>mesh buffers in clean destination buffers will be moved immediately, ones in dirty buffers will be left until the next update </p>

</div>
</div>
<a class="anchor" id="a468a4ebaf0ec5f53f36f438579855775"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool irr::scene::CBatchingMesh::moveMeshBuffer </td>
          <td>(</td>
          <td class="paramtype">const s32&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const core::matrix4 &amp;&#160;</td>
          <td class="paramname"><em>newMatrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Moves a mesh buffer. </p>
<p>if the destination buffer is clean it will be moved immediately, if a member of a dirty buffer, it will be left until the next update </p>

</div>
</div>
<a class="anchor" id="a1f9ede4f4f54878aa2a45333ec125899"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void irr::scene::CBatchingMesh::setMaterialFlag </td>
          <td>(</td>
          <td class="paramtype">video::E_MATERIAL_FLAG&#160;</td>
          <td class="paramname"><em>flag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>newvalue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a flag of all contained materials to a new value. </p>
<dl class="params"><dt>Аргументы</dt><dd>
  <table class="params">
    <tr><td class="paramname">flag</td><td>Flag to set in all materials. </td></tr>
    <tr><td class="paramname">newvalue</td><td>New value to set in all materials. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>Объявления и описания членов класса находятся в файле:<ul>
<li><a class="el" href="_c_batching_mesh_8h_source.html">CBatchingMesh.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Документация по IrrSimpleVoxelEngine. Последние изменения: Чт 17 Сен 2015 12:55:37. Создано системой &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
